0001   0000             ;***********************************************************
0002   0000             ;*                                                         *
0003   0000             ;*    COPYRIGHT , MULTITECH INDUSTRIAL CORP. 1981          *
0004   0000             ;*    All right reserved.                                  *
0005   0000             ;*    No part of this software may be copied without       *
0006   0000             ;*    the express written consent of MULTITECH             *
0007   0000             ;     INDUSTRIAL CORP.
0008   0000             ;*                                                         *
0009   0000             ;***********************************************************
0010   0000             
0011   0000             
0012   0000             
0013   0000             
0014   0000             
0015   0000             P8255	.equ	03H	; 8255 I control port
0016   0000             DIGIT	.equ	02H	; 8255 I port C
0017   0000             SEG7	.equ	01H	; 8255 I port B
0018   0000             KIN	.equ	00H	; 8255 I port A
0019   0000             PWCODE	.equ	0A5H	; Power-up code
0020   0000             ZSUM	.equ	71H	; This will make the sum of all
0021   0000             			; monitor codes to be zero
0022   0000             
0023   0000             ; The following EQUATEs are used for timing.  Their values
0024   0000             ; depend on the CPU clock frequency. (In this version, the
0025   0000             ; crystal frequency is 1.79 MHz.)
0026   0000             
0027   0000             COLDEL	.equ	201	; Column delay time for routine
0028   0000             			; SCAN and SCAN1.
0029   0000             F1KHZ	.equ	65	; Delay count for 1KHz square wave,
0030   0000             			; used by routine TONE1K.
0031   0000             F2KHZ	.equ	31	; Delay count for 2KHz square wave,
0032   0000             			; used by routine TONE2K.
0033   0000             MPERIOD	.equ	42	; 1KHz and 2KHz threshold, used by
0034   0000             			; tape input routine PERIOD.
0035   0000             
0036   0000             ; The following EQUATEs are for tape modulation.
0037   0000             ; If the quality of tape recorder is good, the user may
0038   0000             ; change '4 4 2 8' to '2 2 1 4'. This will improve
0039   0000             ; the tape data rate.
0040   0000             ; If the quality of tape recorder is poor, the user may
0041   0000             ; change '4 4 2 8' to '6 6 3 12'. This will improve
0042   0000             ; error performance but slow down the data rate.
0043   0000             ; Although the data format is changed, the tape is still
0044   0000             ; compatible in each case, because only the ratio is
0045   0000             ; detected in the Tape-read.
0046   0000             
0047   0000             ONE_1K	.equ	4
0048   0000             ONE_2K	.equ	4
0049   0000             ZERO_1K	.equ	2
0050   0000             ZERO_2K	.equ	8
0051   0000             
0052   0000             ;***********************************************************
0053   0000             ; I/O port assignment: (8255 I)
0054   0000             ;
0055   0000             ; port A (address 00H):
0056   0000             ;       bit 7 -- tape input
0057   0000             ;       bit 6 -- 'USER KEY' on keyboard, active low
0058   0000             ;       bit 5-0 row of keyboard matrix input, active low
0059   0000             ; port B (address 01H): 7 segments of LED, active high
0060   0000             ;       bit 7 -- segment d
0061   0000             ;       bit 6 -- decimal point
0062   0000             ;       bit 5 -- segment c
0063   0000             ;       bit 4 -- segment b
0064   0000             ;       bit 3 -- segment a
0065   0000             ;       bit 2 -- segment f
0066   0000             ;       bit 1 -- segment g
0067   0000             ;       bit 0 -- segment e
0068   0000             ; port C (address 02H):
0069   0000             ;       bit 7 -- tape & tone output
0070   0000             ;       bit 6 -- BREAK enable. NMI (CPU pin 17) will go to
0071   0000             ;                low 5 M1's (machine cycle one) after this
0072   0000             ;                bit goes to low. (This bit is connected to
0073   0000             ;                the reset input of external counter.)
0074   0000             ;       bit 5-0 -- columns of keyboard and display matrix,
0075   0000             ;                active high. Bit 5 is the leftmost column.
0076   0000             
0077   0000             ;***********************************************************
0078   0000             ;  -- reset --
0079   0000             ; There are two cases that will generate a RESET signal:
0080   0000             ;    (i) power-up
0081   0000             ;   (ii) 'RS' key pressed
0082   0000             ; In both cases, the following actions will be taken:
0083   0000             ;   a) disable interrupt, set interrupt mode to 0
0084   0000             ;      set I register to 00 and start execution
0085   0000             ;      at address 0000 (by Z80 CPU itself).
0086   0000             ;   b) initialise user's PC to the lowest RAM address;
0087   0000             ;   c) set user's SP to USERSTK;
0088   0000             ;   d) set user's I register to 00 and disable user's
0089   0000             ;      interrupt flip-flop;
0090   0000             ; In addition, subroutine INI will be called on power-up
0091   0000             ; reset, which has the following effects:
0092   0000             ;   e) disable BREAL POINT;
0093   0000             ;   f) set the contents of location IM1AD  1FEFH to 66 and
0094   0000             ;      00 respectively. This will make instruction RST
0095   0000             ;      38H (opcode FF) have the same effect as break.
0096   0000             ; Memory location POWERUP is used to distinguish power-up
0097   0000             ; from RS-key.  (POWERUP) contains a random data when
0098   0000             ; power-up and contains PWCODE (0A5H) thereafter.
0099   0000             	.org	0000h
0100   0000 06 00       	LD 	B, 0
0101   0002 10 FE       	DJNZ	$		; Power-up delay
0102   0004             
0103   0004             ; Initialise 8255 to mode 0 with port A input, port B and C
0104   0004             ; output. The control word is 90H.
0105   0004             
0106   0004 3E 90       	LD 	A,10010000b
0107   0006 D3 03       	OUT	(P8255),A
0108   0008             
0109   0008             ; When the controll word is sent to 8255, all output
0110   0008             ; ports are cleared to 0.  It is necessary to disable
0111   0008             ; BREAK and deactivate all I/O by sending 0C0H to
0112   0008             ; port C.
0113   0008             
0114   0008 3E C0       	LD	A,0C0H
0115   000A D3 02       	OUT	(DIGIT),A
0116   000C 31 AF 1F    	LD	SP,SYSSTK
0117   000F             
0118   000F             ; If the content of location POWERUP is not equal to
0119   000F             ; PWCODE, call subroutine INI. Continue otherwise.
0120   000F             
0121   000F 3A E5 1F    	LD	A,(POWERUP)
0122   0012 FE A5       	CP	PWCODE
0123   0014 C4 C1 03    	CALL	NZ,INI
0124   0017             
0125   0017             ; Determine the lowest RAM address by checking whether
0126   0017             ; address 1000H is RAM.  If yes, set the user's PC to this
0127   0017             ; value.  Otherwise, set it to 1800H.
0128   0017             
0129   0017 21 00 10    	LD	HL,1000H
0130   001A CD F6 05    	CALL	RAMCHK
0131   001D 28 02       	JR	Z,PREPC
0132   001F 26 18       	LD	H,18H
0133   0021 22 DC 1F    PREPC	LD	(USERPC),HL
0134   0024 26 00       	LD	H,00H
0135   0026             
0136   0026             ; Address 28H and 30H are reserved for BREAK (RST 28H)
0137   0026             ; and software BREAK (RST 30H).  Skip these area, monitor
0138   0026             ; program resumes at RESET1.
0139   0026             
0140   0026 18 0A       	JR RESET1
0141   0028             
0142   0028             ;***********************************************************
0143   0028             RST28:	.org	28H
0144   0028             ; Address 28H is the entry point of the BREAK trap.
0145   0028             ; If a location is set as a BREAK point, the monitor
0146   0028             ; will change the constent of this location to C7 (RST 28H)
0147   0028             ; before transferring control to user's program.
0148   0028             ; In execution of user's program, a trap will occur if
0149   0028             ; user's PC passes this location.  The monitor then takes
0150   0028             ; over control and the content of BREAK address
0151   0028             ; will be restored.  Monitor takes care of everything
0152   0028             ; and makes the whole mechanism transparent to the user.
0153   0028             ; The return address pushed onto the stack is the PC after
0154   0028             ; executing RST 28H.  The original break address should
0155   0028             ; be one less than that.  The following 3 instructions
0156   0028             ; decrease the content os (SP) by one without changing
0157   0028             ; HL.
0158   0028             
0159   0028 E3          	EX	(SP),HL
0160   0029 2B          	DEC	HL
0161   002A E3          	EX	(SP),HL
0162   002B 22 E8 1F    	LD	(HLTEMP),HL
0163   002E 18 0E       	JR	CONT28
0164   0030             
0165   0030             ;***********************************************************
0166   0030             RST30	.org	30H
0167   0030             
0168   0030             ; Instruct RST 30H (opcode F7) is usually used as:
0169   0030             ;   i) Software break;
0170   0030             ;  ii) Terminator of user's program.
0171   0030             ; The effect of this instruction is to save all user's
0172   0030             ; registers and return to monitor.
0173   0030             
0174   0030 18 34       	JR	NMI
0175   0032             
0176   0032             ;***********************************************************
0177   0032             ; This is part of the reset routine.  Address 0028 and
0178   0032             ; 0030 are reserved for the break point.  Reset routine
0179   0032             ; skips this area and resumes here.
0180   0032             
0181   0032 22 D2 1F    RESET1	LD	(USERIF),HL	; set user's I register and
0182   0035             				; interrupt flip-flop to 0
0183   0035 18 1D       	JR	RESET2		; monitor resumes at RESET2
0184   0037             
0185   0037             ;***********************************************************
0186   0037             
0187   0037             ; The following byte makes the sum of the monitor
0188   0037             ; code in ROM zero.  ROMTEST is a self-checking routine.
0189   0037             ; This routine requires the sum of ROM to be zero.
0190   0037             
0191   0037 71          	.db	ZSUM
0192   0038             
0193   0038             ;***********************************************************
0194   0038             RST38	.org	38H
0195   0038             
0196   0038             ; Entry point of RST 38H (opcode FF) or mode 1 interrupt.
0197   0038             ; Fetch the address stored in location 1FEE and 1FEF,
0198   0038             ; then jump to this address.  Initially, 1FEE and 1FEF
0199   0038             ; are set to 0066.  So RST 38 will have the same effect
0200   0038             ; as software break.  By changing the content of 1FEE
0201   0038             ; and 1FEF, the user can define his or her own service
0202   0038             ; routine.
0203   0038             ; The next three instructions push the contents of 1FEE
0204   0038             ; and 1FEF to stack without changing any registers
0205   0038             
0206   0038 E5          	PUSH	HL
0207   0039 2A EE 1F    	LD	HL,(IM1AD)
0208   003C E3          	EX	(SP),HL
0209   003D             
0210   003D             ; The top of the stack is now the address of user
0211   003D             ; defined service routine.  Pop out this address then
0212   003D             ; branch to it.
0213   003D             
0214   003D C9          	RET
0215   003E             
0216   003E             ;***********************************************************
0217   003E             CONT28:
0218   003E             ; This is a part of break service routine.  It continues
0219   003E             ; the program at RST28.
0220   003E             
0221   003E 32 E7 1F    	LD	(ATEMP),A
0222   0041             
0223   0041             ; The monitor has changed the content of the user's
0224   0041             ; program at the break address.  The next 3 instructions
0225   0041             ; restored the destroyed content.  BRAD contains the
0226   0041             ; break address, BRDA contains the original data at
0227   0041             ; the break address.
0228   0041              
0229   0041 2A E0 1F    	LD	HL,(BRAD)
0230   0044 3A E2 1F    	LD	A,(BRDA)
0231   0047 77          	LD	(HL),A
0232   0048             
0233   0048             ; Send break enable signal to hardware counter.
0234   0048             ; A non-maskable interrupt will be issued at the 5th m1's.
0235   0048             
0236   0048 3E 80       	LD	A,10000000B
0237   004A D3 02       	OUT	(DIGIT),A
0238   004C 3A E7 1F    	LD	A,(ATEMP)	; 1st M1
0239   004F 2A E8 1F    	LD	HL,(HLTEMP)	; 2nd M1
0240   0052 00          	NOP			; 3rd M1
0241   0053 C9          	RET			; 4th M1
0242   0054             
0243   0054             ; Return to user's program.  Execute the instruction
0244   0054             ; at break address.  After finishing one instruction,
0245   0054             ; a non-maskable interrupt happens and control is
0246   0054             ; transferred to the monitor again.
0247   0054             
0248   0054             RESET2:
0249   0054 21 9F 1F    	LD	HL,USERSTK
0250   0057 22 D0 1F    	LD	(USERSP),HL	; set user's SP
0251   005A AF          	XOR	A
0252   005B 32 E6 1F    	LD	(TEST),A
0253   005E             
0254   005E             ; TEST is a flag for monitor's own use.  Illegal key-in
0255   005E             ; blanking (bit 7 of TEST) and automatic leading zero
0256   005E             ; (bit 0) use this flag.  Clear it here.
0257   005E             
0258   005E DD 21 9F 07 	LD	IX,MPF_I	; Initial display pattern
0259   0062             
0260   0062             ; Address 0066 is the address for non-maskable interrupt.
0261   0062             ; Skip this area, monitor resumes at SETST0
0262   0062             
0263   0062 C3 D0 00    	JP SETST0
0264   0065             
0265   0065             ;***********************************************************
0266   0066             NMI	.org 66H
0267   0066             
0268   0066             ; Entry point of non-maskable interrupt.  NMI will occur
0269   0066             ; when MONI key is pressed or when user's program is
0270   0066             ; breaked.  The service routine which starts here saves all
0271   0066             ; user's registers and status.  It also checks the validity
0272   0066             ; of user's SP.
0273   0066             
0274   0066 32 E7 1F    	LD	(ATEMP),A	; save A register
0275   0069 3E 90       	LD	A,10010000B
0276   006B D3 03       	OUT	(P8255),A	; set 8255 to mode 0.
0277   006D             				; Port A input; B,C output.
0278   006D 3E C0       	LD	A,0C0H
0279   006F D3 02       	OUT	(DIGIT),A	; disable break and LED's
0280   0071 3A E7 1F    	LD	A,(ATEMP)	; restore A register
0281   0074 22 E8 1F    RGSAVE	LD	(HLTEMP),HL	; save register HL
0282   0077 E1          	POP	HL		; get return address from stack
0283   0078 22 DE 1F    	LD	(ADSAVE),HL	; Save return address into
0284   007B             				; ADSAVE.
0285   007B 22 DC 1F    	LD	(USERPC),HL	; Set user's PC to return
0286   007E             				; address.
0287   007E 2A E8 1F    	LD	HL,(HLTEMP)	; restore HL register
0288   0081 ED 73 D0 1F 	LD	(USERSP),SP	; set user's SP to current SP
0289   0085 31 D0 1F    	LD	SP,USERIY+2	; save other registers by
0290   0088 FD E5       	PUSH	IY		; continuously pushing them
0291   008A DD E5       	PUSH	IX		; onto stack
0292   008C D9          	EXX
0293   008D E5          	PUSH	HL
0294   008E D5          	PUSH	DE
0295   008F C5          	PUSH	BC
0296   0090 D9          	EXX
0297   0091 08          	EX	AF,AF'
0298   0092 F5          	PUSH	AF
0299   0093 08          	EX	AF,AF'
0300   0094 E5          	PUSH	HL
0301   0095 D5          	PUSH	DE
0302   0096 C5          	PUSH	BC
0303   0097 F5          	PUSH	AF
0304   0098             
0305   0098             ; The next two instructions save I register.
0306   0098             ; The interrupt flip-flop (IFF2) is copied into
0307   0098             ; parity flag (P/V) by instruction LD A,I.
0308   0098             ; The interrupt status (enabled or disabled)
0309   0098             ; can be determined by testing parity flag.
0310   0098             
0311   0098 ED 57       	LD	A,I
0312   009A 32 D3 1F    	LD	(USERIF+1),A
0313   009D             
0314   009D             ; The next four instructions save IFF2 into
0315   009D             ; user's IFF.
0316   009D             
0317   009D 3E 00       	LD	A,0
0318   009F E2 A4 00    	JP	PO,SETIF	; PO -- P/V = 0
0319   00A2 3E 01       	LD	A,1
0320   00A4 32 D2 1F    SETIF	LD	(USERIF),A
0321   00A7             
0322   00A7 31 AF 1F    	LD	SP,SYSSTK	; set SP to system stack
0323   00AA             
0324   00AA             ; The next 8 instructions check user's SP.
0325   00AA             ; If the user's SP points to a location not
0326   00AA             ; in RAM, display ERR-SP.
0327   00AA             
0328   00AA 2A D0 1F    	LD	HL,(USERSP)
0329   00AD DD 21 B5 07 	LD	IX,ERR_SP
0330   00B1 2B          	DEC	HL
0331   00B2 CD F6 05    	CALL	RAMCHK
0332   00B5 20 19       	JR	NZ,SETST0
0333   00B7 2B          	DEC	HL
0334   00B8 CD F6 05    	CALL	RAMCHK
0335   00BB 20 13       	JR	NZ,SETST0
0336   00BD             
0337   00BD             ; If the user's stack and system stack are
0338   00BD             ; overlayed, display SYS-SP.  This checking
0339   00BD             ; is done by the following instructions
0340   00BD             
0341   00BD DD 21 AF 07 	LD	IX,SYS_SP
0342   00C1 00          	NOP
0343   00C2 00          	NOP
0344   00C3             
0345   00C3 11 62 E0    	LD	DE,-USERSTK+1
0346   00C6 19          	ADD	HL,DE
0347   00C7 38 07       	JR	C,SETST0
0348   00C9 DD 21 B6 1F 	LD	IX,DISPBF
0349   00CD 37          	SCF			; set carry flag to indicate
0350   00CE             				; the user's SP is legal.
0351   00CE 18 04       	JR	BRRSTO
0352   00D0             
0353   00D0             SETST0:
0354   00D0             ; STATE is a memory location contains the monitor status.
0355   00D0             ; It will be described in detial later. STATE 0 stands
0356   00D0             ; for fixed display pattern.  The initial pattern 'uPF--1'
0357   00D0             ; or message 'SYS-SP'... belong to this category.  The next
0358   00D0             ; two instruction set STATE to zero.
0359   00D0             
0360   00D0 AF          	XOR	A		; set A to 0, also clear Carry flag
0361   00D1 32 E4 1F    	LD	(STATE),A
0362   00D4 3A E2 1F    BRRSTO	LD	A,(BRDA)	; restore the data at
0363   00D7             				; break address
0364   00D7 2A E0 1F    	LD	HL,(BRAD)
0365   00DA 77          	LD	(HL),A
0366   00DB             
0367   00DB             ; If the user's SP is legal (carry set),
0368   00DB             ; display user's PC and the content at PC.
0369   00DB             ; Otherwise, display fixed message (ERR-SP
0370   00DB             ; or SYS-SP or uPF--1)
0371   00DB DC 0B 04    	CALL	C,MEMDP2
0372   00DE             
0373   00DE             
0374   00DE             ;***********************************************************
0375   00DE             ; Scan the display and keyboard.  When a key is
0376   00DE             ; detected, take proper action according to the
0377   00DE             ; key pressed.
0378   00DE             
0379   00DE             MAIN:
0380   00DE 31 AF 1F    	LD	SP,SYSSTK	; Initial system stack
0381   00E1 CD FE 05    	CALL	SCAN		; Scan display and input keys.
0382   00E4             				; Routine SCAN will not return until
0383   00E4             				; any key is pressed.
0384   00E4 CD CB 06    	CALL	BEEP		; After a key is detected, there
0385   00E7             				; will be accompanied with a beep
0386   00E7             				; sound.
0387   00E7 18 F5       	JR	MAIN		; Back to MAIN, get more keys and
0388   00E9             				; execute them.
0389   00E9             
0390   00E9             
0391   00E9             ;***********************************************************
0392   00E9             KEYEXEC:
0393   00E9             
0394   00E9             ; Input key dispatch routine.
0395   00E9             ; This routine uses the key code returned by subroutine
0396   00E9             ; SCAN, which is one byte stored in A register.  The
0397   00E9             ; range of key code is from 00 to 1FH.
0398   00E9             
0399   00E9             ; (i) key code = 00H - 0FH :
0400   00E9             ;     These are hexadecimal keys.  Branch to routine KHEX.
0401   00E9             
0402   00E9 FE 10       	CP	10H
0403   00EB 38 24       	JR	C,KHEX
0404   00ED             
0405   00ED             ; If the key entered is not hexadecimal, it must be a
0406   00ED             ; function or subfunction key.  This means the previous
0407   00ED             ; numeric entry has terminated.  Bit 0 of TEST flag
0408   00ED             ; must be set at the beginning of a new numeric entry.
0409   00ED             ; This is done by the next two instructions.  (If bit 0
0410   00ED             ; of TEST is set, the data buffer will be automatically
0411   00ED             ; cleared when a hexadecimal key is entered.)
0412   00ED             
0413   00ED 21 E6 1F    	LD	HL,TEST
0414   00F0 CB C6       	SET	0,(HL)
0415   00F2             
0416   00F2             ; (ii) key code = 10H - 17H :
0417   00F2             ;      (+, -, GO, STEP, DATA, SBR, INS, DEL)
0418   00F2             ;      There is no state corresponding to these keys.
0419   00F2             ;      The response of them depends on the current
0420   00F2             ;      state and minor-state. (E.g., the response of '+'
0421   00F2             ;      key depends on the current function.  It is illegal
0422   00F2             ;      when the display is 'uPF--1', but is legal when the
0423   00F2             ;      display is of 'address-data' form.)  In this
0424   00F2             ;      documentation, they are named 'sub-function key'.
0425   00F2             ;      They are all branched by table KSUBFUN and routine
0426   00F2             ;      BRANCH.
0427   00F2             
0428   00F2 D6 10       	SUB	10H
0429   00F4 FE 08       	CP	8
0430   00F6 21 37 07    	LD	HL,KSUBFUN
0431   00F9 DA B0 03    	JP	C,BRANCH
0432   00FC             
0433   00FC             ;(iii) key code = 18H - 1FH
0434   00FC             ;      (PC, Addr, CBr, Reg, Move, Rela, WRtape, RDtape)
0435   00FC             ;      These keys are named 'function key'. They are
0436   00FC             ;      acceptable at any time.  When they are hit, the
0437   00FC             ;      monitor will unconditionally enter a new state.
0438   00FC             ;      STMINOR contains the minor-state, which is required
0439   00FC             ;      to dispatch some sub-function keys (e.g. +, -). 
0440   00FC             
0441   00FC DD 21 B6 1F 	LD	IX,DISPBF
0442   0100 D6 08       	SUB	8
0443   0102 21 E4 1F    	LD	HL,STATE
0444   0105 77          	LD	(HL),A		; set STATE to key-code minus 18H
0445   0106             				; The STATE is updated here.  It will
0446   0106             				; be modified later by local service
0447   0106             				; routines if the function-key is PC,
0448   0106             				; Addr or CBr.  For other function-
0449   0106             				; keys, STATE will not be modified
0450   0106             				; later.
0451   0106 21 E3 1F    	LD	HL,STMINOR
0452   0109 36 00       	LD	(HL),0		; set STMINOR to 0
0453   010B 21 41 07    	LD	HL,KFUN		; KFUN is the base of branch table
0454   010E             				; the offset is stored in A
0455   010E C3 B0 03    	JP	BRANCH
0456   0111             
0457   0111             
0458   0111             ;***********************************************************
0459   0111             ; STATE:
0460   0111             ;   0=FIX	; Display fixed patter, e.g. 'uPF--1'.
0461   0111             ;   1=AD	; The hex key entered is interpreted as
0462   0111             		; memory address.
0463   0111             ;   2=DA	; The hex key entered is interpreted as
0464   0111             		; memory data.
0465   0111             ;   3=RGFIX	 Display fixed pattern: 'Reg- ' and
0466   0111             		; expect register name to be entered.
0467   0111             ;   4=MV	; Expect parameters for 'Move' function.
0468   0111             ;   5=RL	; Expect parameters for 'Rela' function.
0469   0111             ;   6=WT	; Expect parameters for 'WRtape' function.
0470   0111             ;   7=RT	; Expect parameters for 'RDtape' function.
0471   0111             ;   8=RGAD	; Hex-key entered will be interpreted as
0472   0111             		; address name for registers.
0473   0111             ;   9=RGDA	; Hex-key entered will be interpreted as
0474   0111             		; data for registers.
0475   0111             
0476   0111             ; Subroutine name conventions:
0477   0111             ;    (i) K???? -- K stands for key, ???? is the key name,
0478   0111             ;                 e.g. KINS corresponds to key 'INS'. Each
0479   0111             ;                 time a key ???? is entered, the routine
0480   0111             ;                 with name K???? will be executed.  All of
0481   0111             ;                 them are branched by table KFUN or KSUBFUN.
0482   0111             ;   (ii) H???? -- H stands for hexadecimal, ???? is the
0483   0111             ;                 current STATE.  For example, routine
0484   0111             ;                 HDA will be executed if the entered
0485   0111             ;                 key is hexadecimal and STATE is DA now.
0486   0111             ;                 These routines are branched by table
0487   0111             ;                 HTAB.
0488   0111             ;  (iii) I???? -- I stands for increment (+ key), ???? is
0489   0111             ;                 the current STATE.  E.g. IMV will be
0490   0111             ;                 executed when STATE is MV and '+' key
0491   0111             ;                 is entered.  These routines are branched
0492   0111             ;                 by table ITAB
0493   0111             ;   (iv) D???? -- D stands for decrement (- key), ???? is
0494   0111             ;                 the current STATE.  These routines are
0495   0111             ;                 branched using table DTAB
0496   0111             ;    (v) G???? -- G stands for 'GO' key, ???? is the current
0497   0111             ;                 STATE.  These routines are branched using
0498   0111             ;                 table GTAB
0499   0111             
0500   0111             ;***********************************************************
0501   0111             
0502   0111             ; Hexadecimal, '+', '-' and 'GO' key may be entered after
0503   0111             ; different function keys.  The monitor uses branch tables
0504   0111             ; and STATE to determine the current function and branch
0505   0111             ; to the proper entry point.
0506   0111             
0507   0111             KHEX:
0508   0111             ; Executed when hexadecimal keys are pressed.
0509   0111             ; Use HTAB and STATE for further branch.
0510   0111             
0511   0111 4F          	LD	C,A		; save A register in C
0512   0112             				; which is the hex code-code
0513   0112 21 4B 07    	LD	HL,HTAB
0514   0115 3A E4 1F    BR1	LD	A,(STATE)
0515   0118 C3 B0 03    	JP	BRANCH
0516   011B             
0517   011B             
0518   011B             KINC:
0519   011B             ; Branched by KSUBFUN table.
0520   011B             ; Executed when '+' key is pressed.
0521   011B             ; Use ITAB and STATE for further branch.
0522   011B             ; STATE will be stored in A register at BR1.
0523   011B             
0524   011B 21 57 07    	LD	HL,ITAB
0525   011E 18 F5       	JR	BR1
0526   0120             
0527   0120             
0528   0120             KDEC:
0529   0120             ; Branched by KSUBFUN table.
0530   0120             ; Executed when '-' key is pressed.
0531   0120             ; Use DTAB and STATE for further branch.
0532   0120             ; STATE will be stored in A register at BR1.
0533   0120             
0534   0120 21 63 07    	LD	HL,DTAB
0535   0123 18 F0       	JR	BR1
0536   0125             
0537   0125             
0538   0125             KGO:
0539   0125             ; Branched by KSUBFUN table.
0540   0125             ; Executed when 'GO' key is pressed.
0541   0125             ; Use GTAB and STATE for further branch.
0542   0125             ; STATE will be stored in A register at BR1.
0543   0125             
0544   0125 21 6F 07    	LD	HL,GTAB
0545   0128 18 EB       	JR	BR1
0546   012A             
0547   012A             
0548   012A             KSTEP:
0549   012A             ; Branched by KSUBFUN table.
0550   012A             ; Executed when 'STEP' key is pressed.
0551   012A             
0552   012A CD E5 03    	CALL	TESTM		; Check if the left 4 digits
0553   012D             				; of the display are memory address.
0554   012D             				; If not, disable all LED's as
0555   012D             				; a warning to the user.  This
0556   012D             				; is done by routine IGNORE.
0557   012D C2 BB 03    	JP	NZ,IGNORE
0558   0130 3E 80       	LD	A,10000000B	; This data will be output
0559   0132             				; to port B to enable
0560   0132             				; BREAK.  It is done by
0561   0132             				; routine PREOUT.
0562   0132 C3 A3 02    	JP	PREOUT
0563   0135             
0564   0135             
0565   0135             KDATA:
0566   0135             ; Branched by KSUBFUN table.
0567   0135             ; Executed when 'DATA' key is pressed.
0568   0135             
0569   0135 CD E5 03    	CALL	TESTM		; Check if the left 4 digits
0570   0138             				; of the display are memory address.
0571   0138 20 04       	JR	NZ,TESTRG	; If not, branch to TESTRG
0572   013A             				; to check whether the display
0573   013A             				; is register or not.
0574   013A CD 0B 04    	CALL	MEMDP2		; If yes, display the data of
0575   013D             				; that address and set STATE
0576   013D             				; to 2.
0577   013D C9          	RET
0578   013E FE 08       TESTRG	CP	08H		; check if the status is 8 or 9
0579   0140             				; (RGAD or RGDA).
0580   0140 DA BB 03    	JP	C,IGNORE	; If not, ignore this key and
0581   0143             				; send out a warning message.
0582   0143 CD 77 04    	CALL	REGDP9		; If yes, display register and
0583   0146             				; set status to 9 (RGDA).
0584   0146 C9          	RET
0585   0147             
0586   0147             
0587   0147             KSBR:
0588   0147             ; Branched by KSUBFUN table.
0589   0147             ; Executed when 'SBr' key (set break point) is
0590   0147             ; pressed.
0591   0147             
0592   0147 CD E5 03    	CALL	TESTM		; Check if the display is of
0593   014A             				; 'address-data' form.
0594   014A C2 BB 03    	JP	NZ,IGNORE	; If not, ignore this key and
0595   014D             				; send out a warning message.
0596   014D 2A DE 1F    	LD	HL,(ADSAVE)	; If yes, get the address
0597   0150             				; being displayed now.
0598   0150 CD F6 05    	CALL	RAMCHK		; Check if this address is
0599   0153             				; in RAM.
0600   0153 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore the 'SBR' key
0601   0156             				; and send out a warning message.
0602   0156 22 E0 1F    	LD	(BRAD),HL	; If yes, set this address as
0603   0159             				; a break point.
0604   0159 CD 0B 04    	CALL	MEMDP2		; Display the data of break
0605   015C             				; address and set STATE to
0606   015C             				; 2 (DA).
0607   015C C9          	RET
0608   015D             
0609   015D             
0610   015D             KINS:
0611   015D             ; Branched by KSUBFUN table.
0612   015D             ; Executed when 'INS' key (insert) is pressed.
0613   015D             
0614   015D CD E5 03    	CALL	TESTM		; Check if the display is of
0615   0160             				; 'address-data' form.
0616   0160 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore 'INS' key and
0617   0163             				; send out a warning message.
0618   0163 2A DE 1F    	LD	HL,(ADSAVE)	; If yes, get the address
0619   0166             				; being displayed now.
0620   0166 00          	NOP
0621   0167             
0622   0167             ;	LD (SYSSTK),HL<-dissassembly is different
0623   0167 22 AF 1F    	LD	(STEPBF),HL	; Store this address in
0624   016A             				; STEPBF and the next address
0625   016A             				; in STEPBF+4 for later use
0626   016A 23          	INC	HL
0627   016B 22 B3 1F    	LD	(STEPBF+4),HL
0628   016E CD F6 05    	CALL	RAMCHK		; Check if the address is to be
0629   0171             				; inserted is in RAM.
0630   0171 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore the 'INS' key
0631   0174             				; and send out a warning message.
0632   0174             				; If the address to be inserted
0633   0174             				; is 1n 1800-1DFF, store 1DFE into
0634   0174             				; STEPBF+2
0635   0174             				; Otherwise, ignore the 'INS' key.
0636   0174             				; This is done by the following
0637   0174             				; instructions.
0638   0174 11 FE 1D    	LD	DE,1DFEH
0639   0177 7C          	LD	A,H
0640   0178 FE 1E       	CP	1EH
0641   017A 38 07       	JR	C,SKIPH1
0642   017C FE 20       	CP	20H
0643   017E DA BB 03    	JP	C,IGNORE
0644   0181 16 27       	LD	D,27H
0645   0183 ED 53 B1 1F SKIPH1	LD	(STEPBF+2),DE
0646   0187             
0647   0187             ; When one byte is inserted at some
0648   0187             ; address, all data below this address
0649   0187             ; will be shifted down one position.
0650   0187             ; The last location will be shifted out
0651   0187             ; and therefore lost.
0652   0187             ; The RAM is divided into 3 blocks as
0653   0187             ; insert is concerned.  They are:
0654   0187             ; 1800-1DFF, 1E00-1FF and 2000-27FF
0655   0187             ; The second block cannot be inserted and
0656   0187             ; is usually used as a data bank.  System
0657   0187             ; data that of course cannot be shifted
0658   0187             ; are also stored in this bank.  Each
0659   0187             ; is independent of the other when
0660   0187             ; shift is performd, i.e., the data
0661   0187             ; shifted out of the first block will not
0662   0187             ; be propagated to the next block.
0663   0187             ; The shift is accomplished by block
0664   0187             ; transfer, i.e. MOVE.  This is the
0665   0187             ; job of subroutine GMV.
0666   0187             ; Routine needs 3 parameters which
0667   0187             ; are stored in step-buffer (STEPBF):
0668   0187             ; STEPBF: starting address (2 bytes)
0669   0187             ; STEPBF+2: ending address (2 bytes)
0670   0187             ; STEPBF+4: destination address (2 bytes)
0671   0187             
0672   0187 CD E4 02    DOMV	CALL	GMV
0673   018A AF          	XOR	A		; After the RAM has been shifted down
0674   018B             				; the data of the address to be inserted
0675   018B             				; is cleared to zero.  This is done by
0676   018B             				; the next two instructions.  Register
0677   018B             				; DE contains inserted address after GMV
0678   018B             				; is performed.
0679   018B 12          	LD	(DE),A
0680   018C 2A B3 1F    	LD	HL,(STEPBF+4)	; Store the data is (STEPBF+4)
0681   018F 22 DE 1F    	LD	(ADSAVE),HL	; into (ADSAVE).
0682   0192 CD 0B 04    	CALL	MEMDP2		; Display the address and data, also
0683   0195             				; set STATE to 2.
0684   0195 C9          	RET
0685   0196             
0686   0196             KDEL:
0687   0196             ; Branched by KSUBFUN table.
0688   0196             ; Executed when 'DEL' (delete) key is pressed.
0689   0196             
0690   0196 CD E5 03    	CALL	TESTM		; Check if the display is of
0691   0199             				; 'address-data' form.
0692   0199 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore 'DEL' key and
0693   019C             				; send out a warning message.
0694   019C             				; 'Delete' is quite similar to
0695   019C             				; 'Insert', except that the memory
0696   019C             				; is shifted up instead of shifted
0697   019C             				; down.  See the comments on
0698   019C             				; routine KINS for detail.
0699   019C 2A DE 1F    	LD	HL,(ADSAVE)	; Get the address being displayed
0700   019F             				; now.  This is the address to
0701   019F             				; be deleted.
0702   019F             
0703   019F             
0704   019F 00          	NOP
0705   01A0             
0706   01A0 22 B3 1F    	LD	(STEPBF+4),HL
0707   01A3 CD F6 05    	CALL	RAMCHK		; Check if the address is in RAM.
0708   01A6 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore this key and
0709   01A9             				; send out a warning message.
0710   01A9             				; Following instructions prepare the
0711   01A9             				; parameters for routine GMV in step-
0712   01A9             				; buffer.  Refer to routine KINS for
0713   01A9             				; detail.
0714   01A9 11 00 1E    	LD	DE,1E00H
0715   01AC 7C          	LD	A,H
0716   01AD FE 1E       	CP	1EH
0717   01AF 38 07       	JR	C,SKIPH2
0718   01B1 FE 20       	CP	20H
0719   01B3 DA BB 03    	JP	C,IGNORE
0720   01B6 16 28       	LD	D,28H
0721   01B8 ED 53 B1 1F SKIPH2	LD	(STEPBF+2),DE
0722   01BC 23          	INC	HL
0723   01BD 22 AF 1F    	LD	(STEPBF),HL
0724   01C0 18 C5       	JR	DOMV
0725   01C2             
0726   01C2             ;***********************************************************
0727   01C2             KPC:
0728   01C2             ; Branched by KSUBFUN table.
0729   01C2             ; Executed when 'PC' key is pressed.
0730   01C2             
0731   01C2 2A DC 1F    	LD	HL,(USERPC)	; Store the user's program
0732   01C5 22 DE 1F    	LD	(ADSAVE),HL	; counter into (ADSAVE)
0733   01C8 CD 0B 04    	CALL	MEMDP2		; Routine MEMDP2 displays the address
0734   01CB             				; in (ADSAVE) and its data.  Also
0735   01CB             				; set STATE to 2.
0736   01CB C9          	RET
0737   01CC             
0738   01CC             KCBR:
0739   01CC             ; Branched by KSUBFUN table.
0740   01CC             ; Executed when 'CBr' (clear break point) key is pressed.
0741   01CC             
0742   01CC CD DE 03    	CALL	CLRBR		; Call subroutine CBRBR to clear
0743   01CF             				; break point.  When returned, the HL
0744   01CF             				; register will contain FFFF.
0745   01CF 22 DE 1F    	LD	(ADSAVE),HL	; Store FFFF into (ADSAVE)
0746   01D2 CD 0B 04    	CALL	MEMDP2		; Display address and its data.  Also
0747   01D5             				; set STATE to 2.
0748   01D5 C9          	RET
0749   01D6             
0750   01D6             KREG:
0751   01D6             ; Branched by KSUBFUN table.
0752   01D6             ; Executed when 'Reg' key is pressed.
0753   01D6 DD 21 CA 07 	LD	IX,REG_		; Routine SCAN uses IX as a pointer
0754   01DA             				; for display buffer.  Set IX to REG
0755   01DA             				; will make SCAN display 'Reg-'
0756   01DA CD C4 04    	CALL	FCONV		; Decode users flag F and F' to
0757   01DD             				; binary display format.  This
0758   01DD             				; format will be used later, when
0759   01DD             				; user requires the monitor to
0760   01DD             				; display decoded flag by pressing
0761   01DD             				; keys 'SZXH', 'XPNC',...
0762   01DD C9          	RET
0763   01DE             
0764   01DE             KADDR:
0765   01DE             ; Branched by KSUBFUN table.
0766   01DE             ; Executed when 'Addr' key is pressed.
0767   01DE             
0768   01DE CD 02 04    	CALL	MEMDP1		; Display the address stored in
0769   01E1             				; (ADSAVE) and its data.  Set STATE
0770   01E1             				; to 1 (AD).
0771   01E1 C9          	RET
0772   01E2             
0773   01E2             ; Function Move, Relative, Read-tape and
0774   01E2             ; Write-tape require from one to three
0775   01E2             ; parameters.  They are stored in STEPBF
0776   01E2             ; (step buffer). STMINOR (minor status)
0777   01E2             ; contains the number of parameters that has
0778   01E2             ; been entered.  For Move and Relative, the
0779   01E2             ; default value of the first parameter is
0780   01E2             ; the address stored in (ADSAVE).  There
0781   01E2             ; is no default value for the first parameter
0782   01E2             ; (filename) of Read- and Write-tape.  When the
0783   01E2             ; function keys are pressed, STMINOR is automatically
0784   01E2             ; reset to 0.
0785   01E2             
0786   01E2             
0787   01E2             KMV:
0788   01E2             ; Branched by KSUBFUN table.
0789   01E2             ; Executed when 'Move' key is pressed.
0790   01E2             KRL:
0791   01E2             ; Branched by KSUBFUN table.
0792   01E2             ; Executed when 'Rela' (relative) key is pressed.
0793   01E2 2A DE 1F    	LD	HL,(ADSAVE)	; Store the contents of ADSAVE
0794   01E5             				; into STEPBF as default value
0795   01E5             				; of first parameter.
0796   01E5 22 AF 1F    	LD	(STEPBF),HL
0797   01E8             KWT:
0798   01E8             ; Branched by KSUBFUN table.
0799   01E8             ; Executed when 'WRtape' key is pressed.
0800   01E8             
0801   01E8             KRT:
0802   01E8             ; Branched by KSUBFUN table.
0803   01E8             ; Executed when 'RDtape' key is pressed.
0804   01E8             
0805   01E8 CD 3A 04    	CALL	STEPDP		; Display the parameter that
0806   01EB             				; is being entered now by calling
0807   01EB             				; subroutine STEPDP.
0808   01EB C9          	RET
0809   01EC             
0810   01EC             ;***********************************************************
0811   01EC             ; The following subroutines with the name H??
0812   01EC             ; are the service routines for hexadecimal
0813   01EC             ; keys corresponding to each STATE.  They
0814   01EC             ; are all branched by table HTAB and STATE.
0815   01EC             
0816   01EC C3 BB 03    HFIX	JP	IGNORE		; When the display is fixed pattern
0817   01EF             				; hexadecimal keys are illegal.
0818   01EF             				; Disable all LED's as a warning
0819   01EF             				; message to the user.  This is what
0820   01EF             				; routine IGNORE does.
0821   01EF             
0822   01EF 2A DE 1F    HDA	LD	HL,(ADSAVE)	; Get the address being displayed
0823   01F2             				; now from (ADSAVE)
0824   01F2 CD F6 05    	CALL	RAMCHK		; Check if it is in RAM.
0825   01F5 C2 BB 03    	JP	NZ,IGNORE	; If not, ignore this key and
0826   01F8             				; send out a warning message.
0827   01F8 CD EE 03    	CALL	PRECL1		; If this is the first hexadecimal
0828   01FB             				; key entered after function or sub-
0829   01FB             				; function key, reset the data of that
0830   01FB             				; address to 0. (by routine PERCL1)
0831   01FB 79          	LD	A,C		; The key-code is saved in C at
0832   01FC             				; routine KHEX.  Restore it to A.
0833   01FC ED 6F       	RLD			; Rotate the key-code (4 bits) into
0834   01FE             				; the address obtained above. (in HL)
0835   01FE CD 0B 04    	CALL	MEMDP2		; Display the address and data,
0836   0201             				; then set STATE to 2 (DA).
0837   0201 C9          	RET
0838   0202             
0839   0202 21 DE 1F    HAD:	LD	HL,ADSAVE
0840   0205 CD FA 03    	CALL	PRECL2		; If this is the first hexadecimal
0841   0208             				; key entered after function is entered,
0842   0208             				; set the contents of ADSAVE to 0.
0843   0208 79          	LD	A,C		; The key-code is saved in C
0844   0209             				; by routine KHEX.
0845   0209             				; The next three instructions shift
0846   0209             				; the address being displayed by
0847   0209             				; one digit.
0848   0209 ED 6F       	RLD
0849   020B 23          	INC	HL
0850   020C ED 6F       	RLD
0851   020E CD 02 04    	CALL	MEMDP1		; Display the address and its
0852   0211             				; data.  Also, set STATE to 1.
0853   0211 C9          	RET
0854   0212             
0855   0212             HRGAD:
0856   0212             HRGFIX:
0857   0212 79          	LD	A,C
0858   0213 DD 21 B6 1F 	LD	IX,DISPBF
0859   0217 21 E3 1F    	LD	HL,STMINOR
0860   021A 87          	ADD	A,A		; The ky-code is the register
0861   021B             				; name.  Double it and store it
0862   021B             				; into STMINOR
0863   021B 77          	LD	(HL),A
0864   021C CD 73 04    	CALL	REGDP8		; Display register and set
0865   021F             				; STATE to 8. (RGAD)
0866   021F C9          	RET
0867   0220             
0868   0220             HRT:
0869   0220             HWT:
0870   0220             HRL:
0871   0220 CD 55 04    HMV:	CALL	LOCSTBF		; Use STMINOR and STEPBF
0872   0223             				; to calculate the address
0873   0223             				; of current parameter in
0874   0223             				; step buffer.
0875   0223 CD FA 03    	CALL	PRECL2		; If this is the first hex
0876   0226             				; key entered, clear the
0877   0226             				; parameter (2 bytes) by
0878   0226             				; PRECL2.
0879   0226 79          	LD	A,C		; C contains the key-code.
0880   0227             				; Rotate the parameter (2 bytes)
0881   0227             				; 1 digit left with the key-code.
0882   0227 ED 6F       	RLD
0883   0229 23          	INC	HL
0884   022A ED 6F       	RLD
0885   022C CD 3A 04    	CALL	STEPDP		; display the parameter.
0886   022F C9          	RET
0887   0230             
0888   0230 CD BB 04    HRGDA	CALL	LOCRGBF		; Calculate the address of
0889   0233             				; the register being modified.
0890   0233 CD EE 03    	CALL	PRECL1		; If this is the first hex
0891   0236             				; key entered, clear the register
0892   0236             				; (1 byte) by PRECL1.
0893   0236 79          	LD	A,C		; Rotate user's register (1 byte)
0894   0237             				; 1 digit left with the key-code
0895   0237             				; stored in C.
0896   0237 ED 6F       	RLD
0897   0239 CD 77 04    	CALL	REGDP9		; Display the register set and
0898   023C             				; set STATE to 9 (RGDA).
0899   023C C9          	RET
0900   023D             
0901   023D             ;***********************************************************
0902   023D             ; The following subroutines with
0903   023D             ; name I???? are the service routines for
0904   023D             ; '+' key corresponding to each STATE.
0905   023D             ; They are all branched by table ITAB
0906   023D             ; and STATE.
0907   023D             
0908   023D             IFIX:
0909   023D             IRGFIX:
0910   023D C3 BB 03    	JP	IGNORE		; '+' key is illegal for state
0911   0240             				; FIX or RGFIX, ignore it.
0912   0240             
0913   0240             IAD:
0914   0240 2A DE 1F    IDA:	LD	HL,(ADSAVE)	; Increase the address being
0915   0243             				; displayed now (in ADSAVE)
0916   0243             				; by 1.
0917   0243 23          	INC	HL
0918   0244 22 DE 1F    	LD	(ADSAVE),HL
0919   0247 CD 0B 04    	CALL	MEMDP2		; Display the address and data,
0920   024A             				; then set the STATE to 2.
0921   024A C9          	RET
0922   024B             
0923   024B             IRT:
0924   024B             IWT:
0925   024B             IRL:
0926   024B 21 E3 1F    IMV:	LD	HL,STMINOR	; STMINOR contains the
0927   024E             				; parameter count, increment
0928   024E             				; it by one.
0929   024E 34          	INC	(HL)
0930   024F CD 5F 04    	CALL	LOCSTNA		; Check if the count is
0931   0252             				; overflowed.
0932   0252 20 04       	JR	NZ,ISTEP	; If not overflowed, continue
0933   0254             				; at ISTEP.
0934   0254 35          	DEC	(HL)		; Otherwise, restore the count
0935   0255             				; and ignore the '+' key.
0936   0255 C3 BB 03    	JP	IGNORE
0937   0258 CD 3A 04    ISTEP	CALL	STEPDP		;Display the parameter at
0938   025B             				; step buffer.
0939   025B C9          	RET
0940   025C             
0941   025C             IRGAD:
0942   025C 21 E3 1F    IRGDA:	LD	HL,STMINOR	; In these states, the STMINOR
0943   025F             				; contains the register name.
0944   025F             				; Increase it by 1.  If it
0945   025F             				; reaches the last one, reset
0946   025F             				; it to the first one (0).
0947   025F 34          	INC	(HL)
0948   0260 3E 1F       	LD	A,1FH
0949   0262 BE          	CP	(HL)
0950   0263 30 02       	JR	NC,IRGNA
0951   0265 36 00       	LD	(HL),00H
0952   0267 CD 77 04    IRGNA	CALL	REGDP9		; Display the register and
0953   026A             				; set STATE to 9.
0954   026A C9          	RET
0955   026B             
0956   026B             ;***********************************************************
0957   026B             ; The following subroutines with name
0958   026B             ; D???? are the service routines for
0959   026B             ; '-' key corresponding to each state.
0960   026B             ; They are all branched by table DTAB
0961   026B             ; and STATE.
0962   026B             
0963   026B             DFIX:
0964   026B             DRGFIX:
0965   026B C3 BB 03    	JP	IGNORE		; '-' key is illegal for
0966   026E             				; these states.  Ignore it.
0967   026E             
0968   026E             DAD:
0969   026E 2A DE 1F    DDA:	LD	HL,(ADSAVE)	; Decrease the address being
0970   0271             				; displayed now (in ADSAVE)
0971   0271             				; by one.
0972   0271 2B          	DEC	HL
0973   0272 22 DE 1F    	LD	(ADSAVE),HL
0974   0275 CD 0B 04    	CALL	MEMDP2		; Display the address and data,
0975   0278             				; set STATE to 2 (DA).
0976   0278 C9          	RET
0977   0279             
0978   0279             DRT:
0979   0279             DWT:
0980   0279             DRL:
0981   0279 21 E3 1F    DMV:	LD	HL,STMINOR	; In these states, STMINOR
0982   027C             				; contains the parameter count.
0983   027C             				; Decrease it by one.  If overflow
0984   027C             				; occurs, restore STMINOR and
0985   027C             				; ignore the '-' key.  Otherwise
0986   027C             				; continue at DSTEP.
0987   027C 35          	DEC	(HL)
0988   027D CD 5F 04    	CALL	LOCSTNA
0989   0280 20 04       	JR	NZ,DSTEP
0990   0282 34          	INC	(HL)
0991   0283 C3 BB 03    	JP	IGNORE
0992   0286 CD 3A 04    DSTEP	CALL	STEPDP		; Display the parameters
0993   0289 C9          	RET
0994   028A             
0995   028A             DRGAD:
0996   028A 21 E3 1F    DRGDA:	LD	HL,STMINOR	; In these states, STMINOR
0997   028D             				; contains the register name.
0998   028D             				; Decrease it by one.  If it
0999   028D             				; goes below zero, set it to
1000   028D             				; the highest value (1F).
1001   028D 35          	DEC	(HL)
1002   028E 3E 1F       	LD	A,1FH
1003   0290 BE          	CP	(HL)
1004   0291 30 02       	JR	NC,DRGNA
1005   0293 36 1F       	LD	(HL),1FH
1006   0295 CD 77 04    DRGNA	CALL	REGDP9		; Display the regoster and
1007   0298             				; set STATE to 9.
1008   0298 C9          	RET
1009   0299             
1010   0299             ;***********************************************************
1011   0299             ; The following subroutines with name
1012   0299             ; G???? are the service routines for
1013   0299             ; 'GO' key corresponding to each
1014   0299             ; state.  They are all branched by
1015   0299             ; table GTAB and STATE.
1016   0299             
1017   0299             GFIX:
1018   0299             GRGFIX:
1019   0299             GRGAD:
1020   0299 C3 BB 03    GRGDA:	JP	IGNORE		; 'GO' key is illegal for
1021   029C             				; these states.  Ignore it.
1022   029C             
1023   029C             GAD:
1024   029C 2A E0 1F    GDA:	LD	HL,(BRAD)	; Get the address of break
1025   029F             				; point.
1026   029F 36 EF       	LD	(HL),0EFH	; Instruction RST 28H.
1027   02A1             				; The content of break address
1028   02A1             				; is changed to RST 28H before
1029   02A1             				; the control is transferred to
1030   02A1             				; user's program.  This
1031   02A1             				; will cause a trap when user's
1032   02A1             				; PC passes this point.
1033   02A1 3E FF       	LD	A,0FFH		; Save FF into TEMP.  This data
1034   02A3             				; will be output to port B later.
1035   02A3             				; PC passes this point.
1036   02A3 32 EA 1F    PREOUT	LD	(TEMP),A	; Store A into TEMP
1037   02A6 3A D2 1F    	LD	A,(USERIF)	; Save two instructions into
1038   02A9             				; TEMP and TEMP+1.  These two
1039   02A9             				; instructions will be executed
1040   02A9             				; later.  If the user's IFF
1041   02A9             				; (interrupt flip-flop) is 1,
1042   02A9             				; the instructions are 'EI RET'.
1043   02A9             				; Otherwise, they are 'DI RET'.
1044   02A9 CB 47       	BIT	0,A
1045   02AB 21 FB C9    	LD	HL,0C9FBH	; 'EI', 'RET'
1046   02AE 20 02       	JR	NZ,EIDI
1047   02B0 2E F3       	LD	L,0F3H
1048   02B2 22 EB 1F    EIDI	LD	(TEMP+1),HL
1049   02B5 31 BC 1F    	LD	SP,REGBF	; Restore user's registers by
1050   02B8             				; setting SP to REGBF (register
1051   02B8             				; buffer) and continuously popping
1052   02B8             				; the stack.
1053   02B8 F1          	POP	AF
1054   02B9 C1          	POP	BC
1055   02BA D1          	POP	DE
1056   02BB E1          	POP	HL
1057   02BC 08          	EX	AF,AF'
1058   02BD F1          	POP	AF
1059   02BE 08          	EX	AF,AF'
1060   02BF D9          	EXX
1061   02C0 C1          	POP	BC
1062   02C1 D1          	POP	DE
1063   02C2 E1          	POP	HL
1064   02C3 D9          	EXX
1065   02C4 DD E1       	POP	IX
1066   02C6 FD E1       	POP	IY
1067   02C8 ED 7B D0 1F 	LD	SP,(USERSP)	; Restore user's SP.
1068   02CC 32 BD 1F    	LD	(USERAF+1),A	; Temporarily save A
1069   02CF 3A D3 1F    	LD	A,(USERIF+1)	; Restore user's I
1070   02D2 ED 47       	LD	I,A
1071   02D4 E5          	PUSH	HL		; the nest 3 instructions
1072   02D5             				; push the address being
1073   02D5             				; displayed not (ADSAVE)
1074   02D5             				; onto stack without changing
1075   02D5             				; HL register.  This address will be
1076   02D5             				; treated as user's ne PC.
1077   02D5 2A DE 1F    	LD	HL,(ADSAVE)
1078   02D8 E3          	EX	(SP),HL
1079   02D9 3A EA 1F    	LD	A,(TEMP)	; Output the data stored in
1080   02DC             				; TEMP to port B of 8255.
1081   02DC             				; This data is prepared for
1082   02DC             				; routine KSTEP or GAD or
1083   02DC             				; GDA.  In first case, it is
1084   02DC             				; 10111111 and will enable
1085   02DC             				; break point.  In other
1086   02DC             				; cases, it is FF and will
1087   02DC             				; disable break point.
1088   02DC             				; If break is enables, non-
1089   02DC             				; maskable interrupt will occur
1090   02DC             				; 5 M1's after the OUT instruction.
1091   02DC D3 02       	OUT	(DIGIT),A
1092   02DE 3A BD 1F    	LD	A,(USERAF+1)	; 1st M1,
1093   02E1             				; Restore A register.
1094   02E1 C3 EB 1F    	JP	TEMP+1		; 2nd M1,
1095   02E4             				; Execute the two instructions
1096   02E4             				; stored in RAM.  They are
1097   02E4             				;     EI (or DI)     ; 3rd M1
1098   02E4             				;     RET            ; 4th M1
1099   02E4             				; The starting address of user's
1100   02E4             				; program has been pushed onto
1101   02E4             				; the top of the stack.  RET pops
1102   02E4             				; out this address and transfers
1103   02E4             				; control to it.  The first M1
1104   02E4             				; of users program will be the
1105   02E4             				; 5th M1 after OUT.  If break point
1106   02E4             				; is enabled, NMI will occur after
1107   02E4             				; this instruction is completed.
1108   02E4             				; This is the mechanism of single
1109   02E4             				; step.
1110   02E4             
1111   02E4             ;***********************************************************
1112   02E4 21 AF 1F    GMV	LD	HL,STEPBF
1113   02E7 CD 3D 05    	CALL	GETP		; Load parameters from
1114   02EA             				; step buffer into registers.
1115   02EA             				; Also check if the parameters
1116   02EA             				; are legal.  After GETP,
1117   02EA             				; HL = start address of source
1118   02EA             				; BC = length of MOVE.
1119   02EA 38 67       	JR	C,ERROR		; Jump to ERROR if the
1120   02EC             				; parameters are illegal. (I.e. Ending
1121   02EC             				; address < starting address.)
1122   02EC ED 5B B3 1F 	LD	DE,(STEPBF+4)	; Load destination
1123   02F0             				; address into DE.
1124   02F0 ED 52       	SBC	HL,DE		; Compare HL and DE to
1125   02F2             				; determine move up or down.
1126   02F2 30 0C       	JR	NC,MVUP
1127   02F4             				; Move down:
1128   02F4 EB          	EX	DE,HL		; HL = destination address
1129   02F5 09          	ADD	HL,BC		; HL = dest. address + length
1130   02F6 2B          	DEC	HL		; HL = end address of dest.
1131   02F7 EB          	EX	DE,HL		; DE = end address of dest.
1132   02F8 2A B1 1F    	LD	HL,(STEPBF+2)	; HL - end address of source
1133   02FB ED B8       	LDDR			; block transfer instruction
1134   02FD 13          	INC	DE		; DE = last address moved
1135   02FE 18 1C       	JR	ENDFUN		; Continue at ENDFUN
1136   0300             MVUP:				; Move up:
1137   0300 19          	ADD	HL,DE		; HL is destroyed by
1138   0301             				; SBC HL,DE.  Restore HL.
1139   0301 ED B0       	LDIR			; block transfer
1140   0303 1B          	DEC	DE		; DE = last address moved
1141   0304 18 16       	JR	ENDFUN		; Continue at ENDFUN.
1142   0306             
1143   0306             ;***********************************************************
1144   0306 ED 5B AF 1F GRL	LD	DE,(STEPBF)	; Load starting address
1145   030A             				; into DE.
1146   030A 13          	INC	DE		; Increase this address by 2.
1147   030B             				; Relative address is used in
1148   030B             				; instruction JR or DJNZ.
1149   030B             				; The codes for them are 2 bytes.
1150   030B             				; The PC is increased by 2 after
1151   030B             				; opcode is fetched.
1152   030B 13          	INC	DE
1153   030C 2A B1 1F    	LD	HL,(STEPBF+2)	; Load destination
1154   030F             				; address into HL.
1155   030F B7          	OR	A
1156   0310 ED 52       	SBC	HL,DE		; Calculate difference.
1157   0312 7D          	LD	A,L		; Check if the pffset is between
1158   0313             				; +127 (007FH) and -128 (FF80H).
1159   0313             				; If the offset is positive, both H
1160   0313             				; and but 7 of L must be zero; if it
1161   0313             				; is negative, H and bit 7 of L must
1162   0313             				; be FF and 1.  In both cases, adding
1163   0313             				; H with bit 7 of L results in 0.
1164   0313 17          	RLA			; Rotate bit 7 of L into carry flag.
1165   0314 7C          	LD	A,H
1166   0315 CE 00       	ADC	A,00H		; ADD H and bit 7 of L.
1167   0317 20 3A       	JR	NZ,ERROR	; Branch to error if
1168   0319             				; the result is nonzero.
1169   0319 7D          	LD	A,L
1170   031A 1B          	DEC	DE
1171   031B 12          	LD	(DE),A		; Save the offset into
1172   031C             				; the next byte of opcode.
1173   031C             				; (DJNZ or JR)
1174   031C             
1175   031C             ENDFUN:
1176   031C ED 53 DE 1F 	LD	(ADSAVE),DE	; Save DE into ADSAVE
1177   0320 CD 0B 04    	CALL	MEMDP2		; Display this address and
1178   0323             				; it's data.  Set STATE to 2.
1179   0323 C9          	RET
1180   0324             
1181   0324             ;***********************************************************
1182   0324             GWT:
1183   0324 CD 2D 05    	CALL	SUM1		; Load parameters from
1184   0327             				; step buffer into registers.
1185   0327             				; Check if the parameters
1186   0327             				; are legal.  If legal, calculate
1187   0327             				; the sum of all data to be output
1188   0327             				; to tape.
1189   0327 38 2A       	JR	C,ERROR		; Branch to ERROR if the
1190   0329             				; parameters are illegal. (length is
1191   0329             				; negative)
1192   0329 32 B5 1F    	LD	(STEPBF+6),A	; Store the checksum into
1193   032C             				; STEPBF+6
1194   032C 21 A0 0F    	LD	HL,4000		; Output 1k Hz square
1195   032F             				; wave for 4000 cycles.
1196   032F             				; Leading sync. signal.
1197   032F CD DE 05    	CALL	TONE1K
1198   0332 21 AF 1F    	LD	HL,STEPBF	; Output 7 bytes starting
1199   0335             				; at STEPBF. (Include:
1200   0335             				; filename, starting, ending
1201   0335             				; address and checksum)
1202   0335 01 07 00    	LD	BC,0007H
1203   0338 CD A7 05    	CALL	TAPEOUT		
1204   033B 21 A0 0F    	LD	HL,4000		; Output 2k Hz square
1205   033E             				; wave for 4000 cycles.
1206   033E             				; Middle sync. The file name of the
1207   033E             				; file being read will be displayed
1208   033E             				; in this interval.
1209   033E CD E2 05    	CALL	TONE2K
1210   0341 CD 3A 05    	CALL	GETPTR		; Load parameters into
1211   0344             				; registers. (Starting, ending and
1212   0344             				; length).
1213   0344 CD A7 05    	CALL	TAPEOUT		; Output user's data.
1214   0347 21 A0 0F    	LD	HL,4000		; Output 4000 cycles of
1215   034A             				; 2k Hz square wave.
1216   034A             				; (Tail sync.)
1217   034A CD E2 05    	CALL	TONE2K
1218   034D ED 5B B3 1F ENDTAPE LD	DE,(STEPBF+4)	; DE = last address
1219   0351 18 C9       	JR	ENDFUN		; Continue at ENDFUN.
1220   0353             
1221   0353 DD 21 A9 07 ERROR	LD	IX,ERR_		; IX points to '-Err'
1222   0357 C3 D0 00    	JP	SETST0		; Set STATE to 0 by
1223   035A             				; branching to SETST0
1224   035A             
1225   035A             ;***********************************************************
1226   035A             GRT:
1227   035A 2A AF 1F    	LD	HL,(STEPBF)	; Temporarily save filename.
1228   035D 22 EA 1F    	LD	(TEMP),HL
1229   0360 3E 40       LEAD	LD	A,01000000B	; decimal point
1230   0362 D3 01       	OUT	(SEG7),A	; When searching for filename,
1231   0364             				; the display is blank initially.
1232   0364             				; If the data read from MIC is
1233   0364             				; acceptable 0 or 1, the display
1234   0364             				; becomes '......'.
1235   0364 21 E8 03    	LD	HL,1000
1236   0367 CD 8C 05    LEAD1	CALL	PERIOD		; The return of PERIOD
1237   036A             				; is in flag:
1238   036A             				;  NC -- tape input is 1k Hz;
1239   036A             				;   C -- otherwise.
1240   036A 38 F4       	JR	C,LEAD		; Loop until leading sync.
1241   036C             				; is detected.
1242   036C 2B          	DEC	HL		; Decrease HL by one when
1243   036D             				; one period is detected.
1244   036D 7C          	LD	A,H
1245   036E B5          	OR	L		; Check if both H and L are 0.
1246   036F 20 F6       	JR	NZ,LEAD1	; Wait for 1000 periods.
1247   0371             				; The leading sync. is accepted
1248   0371             				; if it is longer than 1000
1249   0371             				; cycles (1 second).
1250   0371 CD 8C 05    LEAD2	CALL	PERIOD
1251   0374 30 FB       	JR	NC,LEAD2	; Wait all leading sync. to
1252   0376             				; pass over.
1253   0376             
1254   0376 21 AF 1F    	LD	HL,STEPBF	; Load 7 bytes from
1255   0379             				; tape to STEPBF.
1256   0379 01 07 00    	LD	BC,0007H
1257   037C CD 4D 05    	CALL	TAPEIN
1258   037F 38 DF       	JR	C,LEAD		; Jump to LEAD if input
1259   0381             				; is not successful.
1260   0381 ED 5B AF 1F 	LD	DE,(STEPBF)	; Get filename from
1261   0385             				; step buffer.
1262   0385 CD 65 06    	CALL	ADDRDP		; Convert it to display
1263   0388             				; format
1264   0388 06 96       	LD	B,150		; Display it for 1.5 sec.
1265   038A CD 24 06    FILEDP	CALL	SCAN1
1266   038D 10 FB       	DJNZ	FILEDP
1267   038F 2A EA 1F    	LD	HL,(TEMP)	; Check if the input
1268   0392             				; filename equals to the
1269   0392             				; specified filename.
1270   0392 B7          	OR	A
1271   0393 ED 52       	SBC	HL,DE
1272   0395 20 C9       	JR	NZ,LEAD		; If not, find the leading
1273   0397             				; sync. of next file.
1274   0397             
1275   0397             				; If filename is found,
1276   0397 3E 02       	LD	A,00000010B	; Segment '-'
1277   0399 D3 01       	OUT	(SEG7),A	; Display '------'.
1278   039B CD 3A 05    	CALL	GETPTR		; The parameters (starting
1279   039E             				; ending address and check-
1280   039E             				; sum) have been loaded into
1281   039E             				; STEPBF.  Load them into
1282   039E             				; registers, calculate the block
1283   039E             				; length and check if they are
1284   039E             				; legal;
1285   039E 38 B3       	JR	C,ERROR		; Jump to ERROR if the
1286   03A0             				; parameters are illegal.
1287   03A0 CD 4D 05    	CALL	TAPEIN		; Input user's data.
1288   03A3 38 AE       	JR	C,ERROR		; Jump to ERROR if input
1289   03A5             				; is not successful.
1290   03A5 CD 2D 05    	CALL	SUM1		; Calculate the sum of all
1291   03A8             				; input data.
1292   03A8 21 B5 1F    	LD	HL,STEPBF+6
1293   03AB BE          	CP	(HL)		; Compare it with the
1294   03AC             				; checksum calculated by and stored
1295   03AC             				; 'WRtape'.
1296   03AC 20 A5       	JR	NZ,ERROR	; Jump to ERROR if not
1297   03AE             				; matched.
1298   03AE 18 9D       	JR	ENDTAPE		; Continue at ENDTAPE.
1299   03B0             
1300   03B0             ;***********************************************************
1301   03B0             BRANCH:
1302   03B0             ; Branch table format:
1303   03B0             ;    byte 1,2 : address of the 1st routine in
1304   03B0             ;               each group.
1305   03B0             ;    byte 3   : difference between the address
1306   03B0             ;               of 1st and 1st routine, which is
1307   03B0             ;               of course 0.
1308   03B0             ;    byte 4   : difference between the address
1309   03B0             ;               of 2nd and 1st routine
1310   03B0             ;    byte 3   : difference between the address
1311   03B0             ;               of 2nd and 1st routine
1312   03B0             ;     ...
1313   03B0             ;     ...
1314   03B0             ;     ...
1315   03B0             ; HL : address of branch table
1316   03B0             ; A  : the routine number in its group
1317   03B0             ; Such branch table can save table length and avoid page
1318   03B0             ; (256 bytes) boundary problem.
1319   03B0             
1320   03B0 5E          	LD	E,(HL)		; Load the address of 1st
1321   03B1             				; routine in the group into
1322   03B1             				; DE register.
1323   03B1 23          	INC	HL
1324   03B2 56          	LD	D,(HL)
1325   03B3 23          	INC	HL		; Locate the pointer of difference
1326   03B4             				; table.
1327   03B4 85          	ADD	A,L
1328   03B5 6F          	LD	L,A
1329   03B6 6E          	LD	L,(HL)		; Load teh address
1330   03B7             				; difference into L.
1331   03B7 26 00       	LD	H,00H
1332   03B9 19          	ADD	HL,DE		; Get the routine's real address
1333   03BA E9          	JP	(HL)		; Jump to it.
1334   03BB             
1335   03BB             ;***********************************************************
1336   03BB             IGNORE:
1337   03BB 21 E6 1F    	LD	HL,TEST
1338   03BE CB FE       	SET	7,(HL)		; Routine SCAN will check bit
1339   03C0             				; 7 of TEST.  If it is set,
1340   03C0             				; all LED's will be disabled.
1341   03C0             				; This is a warning message to
1342   03C0             				; the user when an illegal key
1343   03C0             				; is entered.
1344   03C0 C9          	RET
1345   03C1             
1346   03C1             ;***********************************************************
1347   03C1             INI:
1348   03C1             ; Power-up initialization.
1349   03C1 DD 21 A5 07 	LD	IX,BLANK	; BLANK is the initial pattern
1350   03C5             
1351   03C5             				; Display the following
1352   03C5             				; patterns sequence, each 0.16
1353   03C5             				; seconds:
1354   03C5             				;     '      '
1355   03C5             				;     '     u'
1356   03C5             				;     '    uP'
1357   03C5             				;     '   uPF'
1358   03C5             				;     '  uPF-'
1359   03C5             				;     ' uPF--'
1360   03C5             				;     'uPF--1'
1361   03C5             	
1362   03C5 0E 07       	LD	C,7		; pattern count
1363   03C7 06 10       INI1	LD	B,10H		; Display 0.16 second.
1364   03C9 CD 24 06    INI2	CALL	SCAN1
1365   03CC 10 FB       	DJNZ	INI2
1366   03CE DD 2B       	DEC	IX		; next pattern
1367   03D0 0D          	DEC	C
1368   03D1 20 F4       	JR	NZ,INI1
1369   03D3             
1370   03D3 3E A5       	LD 	A,PWCODE
1371   03D5 C3 B3 06    	JP	INI3
1372   03D8 21 66 00    INI4	LD	HL,NMI
1373   03DB 22 EE 1F    	LD	(IM1AD),HL	; Set the service routine
1374   03DE             				; of RST 38H to NMI, which is the
1375   03DE             				; nonmaskable interrupt service
1376   03DE             				; routine for break point and
1377   03DE             				; single step.
1378   03DE             CLRBR:	
1379   03DE             ; Clear break point by setting
1380   03DE             ; the break point address to
1381   03DE             ; FFFF. This is a non-existant
1382   03DE             ; address, so break can never happen.
1383   03DE             
1384   03DE 21 FF FF    	LD	HL,0FFFFH
1385   03E1 22 E0 1F    	LD	(BRAD),HL
1386   03E4 C9          	RET
1387   03E5             
1388   03E5             
1389   03E5             TESTM:
1390   03E5             ; Check if the display of 'address-data'
1391   03E5             ; form, i.e. STATE 1 or 2.
1392   03E5             ; The result is stored in zero flag.
1393   03E5             ;    Z:  yes
1394   03E5             ;   NZ:  no
1395   03E5             
1396   03E5 3A E4 1F    	LD	A,(STATE)
1397   03E8 FE 01       	CP	1
1398   03EA C8          	RET	Z
1399   03EB FE 02       	CP	2
1400   03ED C9          	RET
1401   03EE             
1402   03EE             PRECL1:
1403   03EE             ; Pre-clear 1 byte.
1404   03EE             ; If bit 0 of TEST is not 0, load 0 into (HL).  Bit 0 of
1405   03EE             ; TEST is cleared after check.
1406   03EE             ; Only the AF register is destroyed.
1407   03EE             	
1408   03EE 3A E6 1F    	LD	A,(TEST)
1409   03F1 B7          	OR	A		; Is bit 0 of TEST zero?
1410   03F2 C8          	RET	Z
1411   03F3 3E 00       	LD	A,0
1412   03F5 77          	LD	(HL),A		; Clear (HL)
1413   03F6 32 E6 1F    	LD	(TEST),A	; Clear TEST too.
1414   03F9 C9          	RET
1415   03FA             
1416   03FA             PRECL2:
1417   03FA             ; Pre-clear 2 bytes.
1418   03FA             ; If bit 0 of TEST is non-zero, clear (HL)
1419   03FA             ; and (HL+1)
1420   03FA             ; Only the AF register is destroyed.
1421   03FA             
1422   03FA CD EE 03    	CALL	PRECL1
1423   03FD C8          	RET	Z
1424   03FE 23          	INC	HL
1425   03FF 77          	LD	(HL),A
1426   0400 2B          	DEC	HL
1427   0401 C9          	RET
1428   0402             
1429   0402             ;***********************************************************
1430   0402             ; Memory display format: (address-data)
1431   0402             
1432   0402             ;      i) A.A.A.A. D D -- State is AD.  Four decimal points
1433   0402             ;                         under the address field indicate
1434   0402             ;                         that the numeric key entered will
1435   0402             ;                         be interpreted as memory address.
1436   0402             ;     ii) A A A A  D.D.-- State is DA.  Two decimal points
1437   0402             ;                         under the data field indicate
1438   0402             ;                         the monitor is expecting user to
1439   0402             ;                         enter memory data
1440   0402             ;    iii) A.A.A.A. D.D.-- Six decimal points indicate the
1441   0402             ;                         address being displayed is set
1442   0402             ;                         as a break point.
1443   0402             
1444   0402             MEMDP1:
1445   0402 3E 01       	LD	A,1		; Next STATE = 1
1446   0404 06 04       	LD	B,4		; 4 decimal points active
1447   0406 21 B8 1F    	LD	HL,DISPBF+2	; The first active decimal
1448   0409             				; point is in DISPBF+2, the
1449   0409             				; last in DISPBF+5
1450   0409 18 07       	JR	SAV12		; Continue at SAV12.
1451   040B             MEMDP2:
1452   040B 3E 02       	LD	A,2		; Next STATE = 2
1453   040D 06 02       	LD	B,2		; 2 active decimal points
1454   040F 21 B6 1F    	LD	HL,DISPBF	; 1st decimal point is in
1455   0412             				; DISPBF, 2nd in DISPBF+1.
1456   0412 32 E4 1F    SAV12	LD	(STATE),A	; Update STATE
1457   0415 D9          	EXX			; Save register HL, BC, DE.
1458   0416 ED 5B DE 1F 	LD	DE,(ADSAVE)	; The addres to be
1459   041A             				; displayed is stored in
1460   041A             				; (ADSAVE).  Load it into
1461   041A             				; DE register.
1462   041A CD 65 06    	CALL	ADDRDP		; Convert this address to
1463   041D             				; display format and store it
1464   041D             				; into DISPBF+2 - DISPBF+5.
1465   041D 1A          	LD	A,(DE)		; Load the data of this
1466   041E             				; address into A register.
1467   041E CD 71 06    	CALL	DATADP		; Convert this address to
1468   0421             				; display format and store it
1469   0421             				; into DISPBF - DISPBF+1.
1470   0421             BRTEST:
1471   0421             ; The next 3 instructions serve to refresh the
1472   0421             ; data at break address every time memory is
1473   0421             ; displayed.
1474   0421 2A E0 1F    	LD	HL,(BRAD)	; Get break point address.
1475   0424 7E          	LD	A,(HL)		; Get the data of this
1476   0425             				; address into the A register.
1477   0425 32 E2 1F    	LD	(BRDA),A	; Store it into BRDA (break data).
1478   0428 B7          	OR	A
1479   0429 ED 52       	SBC	HL,DE		; Check if the address to
1480   042B             				; be displayed is break point.
1481   042B 20 06       	JR	NZ,SETPT1	; If not, jump to SETPT1.
1482   042D 06 06       	LD	B,6		; 6 active decimal points
1483   042F 21 B6 1F    	LD	HL,DISPBF	; 1st decimal point is in
1484   0432             				; DISPBF; 6th in DISPBF+5.
1485   0432 D9          	EXX
1486   0433 D9          SETPT1	EXX			; Restore HL,BC,DE.
1487   0434 CB F6       SETPT	SET	6,(HL)		; Set decimal points.
1488   0436             				; Count in B, first address
1489   0436             				; in HL register.
1490   0436 23          	INC	HL
1491   0437 10 FB       	DJNZ	SETPT
1492   0439 C9          	RET
1493   043A             
1494   043A             ;***********************************************************
1495   043A             ; Step display format: (this format is used when user is
1496   043A             ; entering parameters for Move, Rela, WRtape, RDtape.)
1497   043A             
1498   043A             ;         P.P.P.P. - N
1499   043A             
1500   043A             ; 'P' is the digit of parameter.  Four decimal points
1501   043A             ; indicate P's are being modifed now.  N is the mnemonic of
1502   043A             ; the parameter:
1503   043A             ;      i) Move   S -- starting address
1504   043A             ;                E -- ending address
1505   043A             ;                D -- destination address
1506   043A             ;     ii) Rela   S -- source address
1507   043A             ;                D -- destination address
1508   043A             ;    iii) WRtape F -- file name
1509   043A             ;                S -- starting address
1510   043A             ;                E -- ending address
1511   043A             ;     iv) RDtape F -- file name
1512   043A             
1513   043A             STEPDP:
1514   043A             ; Display step buffer and its parameter name.
1515   043A             ; Input: STATE
1516   043A             ;        STMINOR (paramater count)
1517   043A             ; registers destroyed: AF,BC,DE,HL
1518   043A             
1519   043A CD 55 04    	CALL	LOCSTBF		; Get parameter address
1520   043D 5E          	LD	E,(HL)		; Load parameter into DE
1521   043E 23          	INC	HL
1522   043F 56          	LD	D,(HL)
1523   0440 CD 65 06    	CALL	ADDRDP		; Convert this parameter to
1524   0443             				; display format (4 digits)
1525   0443             				; and store it into DISPBF+2
1526   0443             				; - DISPBF+5
1527   0443 21 B8 1F    	LD	HL,DISPBF+2	; Set 4 decimal points.
1528   0446             				; From DISPBF+2 to DISPBF+5.
1529   0446 06 04       	LD	B,4
1530   0448 CD 34 04    	CALL	SETPT
1531   044B CD 5F 04    	CALL	LOCSTNA		; Get parameter name.
1532   044E 6F          	LD	L,A
1533   044F 26 02       	LD	H,2		; Pattern '-' for second rightmost
1534   0451             				; digit.
1535   0451 22 B6 1F    	LD	(DISPBF),HL
1536   0454 C9          	RET
1537   0455             
1538   0455             LOCSTBF:
1539   0455             ; Get the location of parameter.
1540   0455             ;  address = STEPBF + STMINOR*2
1541   0455             ; register destroyed: AF,HL
1542   0455             
1543   0455 3A E3 1F    	LD	A,(STMINOR)	; Get parameter count.
1544   0458 87          	ADD	A,A		; Each parameter has 2 bytes.
1545   0459 21 AF 1F    	LD	HL,STEPBF	; Get base address.
1546   045C 85          	ADD	A,L
1547   045D 6F          	LD	L,A
1548   045E C9          	RET
1549   045F             
1550   045F             LOCSTNA:
1551   045F             ; Get parameter name.
1552   045F             ; Input: STATE, STMINOR
1553   045F             ; Output: parameter name in A, and Z flag.
1554   045F             
1555   045F             ; Register destroyed: AF,DE
1556   045F 3A E4 1F    	LD	A,(STATE)	; Get STATE.
1557   0462             				; Possible states are:
1558   0462             				; 4,5,6,7. (Move, Rel,
1559   0462             				; WRtape, RDtape)
1560   0462 D6 04       	SUB	4		; Change 4,5,6,7 to
1561   0464             				; 0,1,2,3
1562   0464 87          	ADD	A,A		; Each state has 4 bytes for names.
1563   0465 87          	ADD	A,A
1564   0466 11 BC 07    	LD	DE,STEPTAB
1565   0469 83          	ADD	A,E
1566   046A 5F          	LD	E,A		; Now DE contains the
1567   046B             				; address of 1st name
1568   046B             				; for each state.
1569   046B 3A E3 1F    	LD	A,(STMINOR)	; Get parameter count
1570   046E 83          	ADD	A,E		; DE <--- DE + A
1571   046F 5F          	LD	E,A
1572   0470 1A          	LD	A,(DE)		; Get parameter name.
1573   0471 B7          	OR	A		; Change zero flag.  If the
1574   0472             				; returned pattern (in A) is
1575   0472             				; zero, the '+' or '-' must
1576   0472             				; have been pressed beyond legal
1577   0472             				; parameter boundary. (Check if
1578   0472             				; parameter name got from STEPTAB
1579   0472             				; is zero)
1580   0472 C9          	RET
1581   0473             
1582   0473             ;***********************************************************
1583   0473             ; Register display format:
1584   0473             
1585   0473             ;       i)  X X X X  Y Y -- State is REGAD.  The numeric data
1586   0473             ;                           entered is interpreted as
1587   0473             ;                           register name.
1588   0473             ;                           YY is the register name, the
1589   0473             ;                           data of that registair pair is
1590   0473             ;                           XXXX.
1591   0473             
1592   0473             ;      ii)  X X X.X. Y Y or
1593   0473             ;     iii)  X.X.X X  Y Y -- State is REGDA.  The unit of
1594   0473             ;                           register modification is byte.
1595   0473             ;                           The numeric data entered will
1596   0473             ;                           change the byte with decimal
1597   0473             ;                           points under it.  Decimal points
1598   0473             ;                           can be moved by '+' or '-' keys.
1599   0473             
1600   0473             REGDP8:
1601   0473             ; Display register and set STATE to 8.
1602   0473             
1603   0473 3E 08       	LD	A,8		; Next state = 8
1604   0475 18 02       	JR RGSTIN
1605   0477             
1606   0477             REGDP9:
1607   0477             ; Display register and set STATE to 9.
1608   0477             
1609   0477 3E 09       	LD	A,9		; Next state = 9
1610   0479             
1611   0479             RGSTIN:
1612   0479             ; Update STATE by register A.
1613   0479             ; Display user's register (count
1614   0479             ; contained in STMINOR).
1615   0479             ; register destroyed: AF,BC,DE,HL
1616   0479             
1617   0479 32 E4 1F    	LD	(STATE),A	; Update STATE.
1618   047C 3A E3 1F    	LD	A,(STMINOR)	; Get register count.
1619   047F CB 87       	RES	0,A		; Registers are displayed by
1620   0481             				; pair.  Find the count
1621   0481             				; of pair leader.  (count of
1622   0481             				; the lower one)
1623   0481 47          	LD	B,A		; Temporarily save A.
1624   0482 CD AE 04    	CALL	RGNADP		; Find register count.
1625   0485             				; Store them into DISPBF
1626   0485             				; and DISPBF+1
1627   0485 78          	LD	A,B		; Restore A (register pair leader).
1628   0486 CD BE 04    	CALL	LOCRG		; Get the address of
1629   0489             				; user's register.
1630   0489 5E          	LD	E,(HL)		; Get register data. (2 bytes)
1631   048A 23          	INC	HL
1632   048B 56          	LD	D,(HL)
1633   048C ED 53 DE 1F 	LD	(ADSAVE),DE	; Convert them to display
1634   0490             				; format and store into
1635   0490             				; display buffer.
1636   0490 CD 65 06    	CALL	ADDRDP
1637   0493 3A E4 1F    	LD	A,(STATE)
1638   0496 FE 09       	CP	9		; If STATE equals to 9 (RGDA),
1639   0498             				; set 2 decimal points.
1640   0498             				; Otherwise return here.
1641   0498 C0          	RET	NZ
1642   0499 21 B8 1F    	LD	HL,DISPBF+2
1643   049C 3A E3 1F    	LD	A,(STMINOR)	; Get register name.
1644   049F CB 47       	BIT	0,A		; If this register is
1645   04A1             				; group leader, set decimal
1646   04A1             				; points to two central digits.
1647   04A1             				; Otherwise set two left digits.
1648   04A1 28 02       	JR	Z,LOCPT
1649   04A3 23          	INC	HL
1650   04A4 23          	INC	HL
1651   04A5 CB F6       LOCPT	SET	6,(HL)		; Set decimal points of
1652   04A7             				; (HL) and (HL+1)
1653   04A7 23          	INC	HL
1654   04A8 CB F6       	SET	6,(HL)
1655   04AA CD C4 04    	CALL	FCONV		; Convert user's flag (F,F')
1656   04AD             				; to binary display format.
1657   04AD C9          	RET
1658   04AE             
1659   04AE             RGNADP:
1660   04AE             ; Get the patterns of register names and
1661   04AE             ; store them into DISPBF and DISPBF+1.
1662   04AE             ; Input: A contains register count of
1663   04AE             ;        pair leader.
1664   04AE             ; register destroyed: AF,DE,HL
1665   04AE             
1666   04AE 21 D0 07    	LD	HL,RGTAB	; Get address of pattern
1667   04B1             				; table
1668   04B1 85          	ADD	A,L
1669   04B2 6F          	LD	L,A
1670   04B3 5E          	LD	E,(HL)		; Get first pattern.
1671   04B4 23          	INC	HL
1672   04B5 56          	LD	D,(HL)		; Get 2nd pattern.
1673   04B6 ED 53 B6 1F 	LD	(DISPBF),DE
1674   04BA C9          	RET
1675   04BB             
1676   04BB             LOCRGBF:
1677   04BB             ; Get the address of user's register.
1678   04BB             ; Register name contained in STMINOR.
1679   04BB             ; Destroys HL, AF.
1680   04BB             
1681   04BB 3A E3 1F    	LD	A,(STMINOR)
1682   04BE 21 BC 1F    LOCRG	LD	HL,REGBF
1683   04C1 85          	ADD	A,L
1684   04C2 6F          	LD	L,A
1685   04C3 C9          	RET
1686   04C4             
1687   04C4             FCONV:
1688   04C4             ; Encode or decode user's flag register.
1689   04C4             ; STMINOR contains the name of the flag
1690   04C4             ; being displayed now.
1691   04C4             ; register detroyed: AF,BC,HL.
1692   04C4             
1693   04C4 3A E3 1F    	LD	A,(STMINOR)	; Get register name.
1694   04C7 B7          	OR	A		; Clear carry flag.
1695   04C8 1F          	RRA			; name of I register: 17H,
1696   04C9             				; name of IFF: 16H.
1697   04C9             				; Rotate right one bit, both
1698   04C9             				; become 0BH.
1699   04C9 FE 0B       	CP	0BH
1700   04CB 28 09       	JR	Z,FLAGX		; Jump to FLAGX if
1701   04CD             				; I or IFF is being
1702   04CD             				; displayed now.
1703   04CD 4F          	LD	C,A		; Otherwise, mask out bit
1704   04CE             				; 1 to bit 7 of user's IFF.
1705   04CE             				; IFF is only 1 bit, monitor
1706   04CE             				; use one byte to store it,
1707   04CE             				; masking out bit 1-7 is to
1708   04CE             				; ignore the useless bits.
1709   04CE             				; This is done only when the
1710   04CE             				; the user is not modifying IFF.
1711   04CE             				; If user is modifying IFF,
1712   04CE             				; monitor will display whatever
1713   04CE             				; he enters, even if bit 1-7
1714   04CE             				; are not all zero.
1715   04CE             				; A register is not changed
1716   04CE             				; after doing this.
1717   04CE 21 D2 1F    	LD	HL,USERIF
1718   04D1 7E          	LD	A,(HL)
1719   04D2 E6 01       	AND	00000001B
1720   04D4 77          	LD	(HL),A
1721   04D5 79          	LD	A,C
1722   04D6 FE 0C       FLAGX	CP	0CH		; If STMINOR contains
1723   04D8             				; the name of SZXH, XPNC,
1724   04D8             				; SZXH' or XPNC', after
1725   04D8             				; rotating right one bit
1726   04D8             				; it will be greater than
1727   04D8             				; or equal to 0CH.
1728   04D8             				; Decode user's flag if it
1729   04D8             				; is not being modified now,
1730   04D8             				; encode it otherwise.
1731   04D8 30 1F       	JR	NC,FCONV2
1732   04DA 3A BC 1F    FCONV1	LD	A,(USERAF)	; Get user's F register.
1733   04DD CD 18 05    	CALL	DECODE		; Decode upper 4 bits.
1734   04E0 22 D4 1F    	LD	(FLAGH),HL
1735   04E3 CD 18 05    	CALL	DECODE		; Decode lower 4 bits.
1736   04E6 22 D6 1F    	LD	(FLAGL),HL
1737   04E9 3A C4 1F    	LD	A,(UAFP)	; Get user's F' register.
1738   04EC CD 18 05    	CALL	DECODE
1739   04EF 22 D8 1F    	LD	(FLAGHP),HL
1740   04F2 CD 18 05    	CALL	DECODE
1741   04F5 22 DA 1F    	LD	(FLAGLP),HL
1742   04F8 C9          	RET
1743   04F9 2A D4 1F    FCONV2	LD	HL,(FLAGH)	; Get the binary form
1744   04FC             				; of 4 upper bits of
1745   04FC             				; user's F register.
1746   04FC CD 23 05    	CALL	ENCODE		; Encode it.
1747   04FF 2A D6 1F    	LD	HL,(FLAGL)	; Encode 4 lower bits.
1748   0502 CD 23 05    	CALL	ENCODE
1749   0505 32 BC 1F    	LD	(USERAF),A	; Save the encoded
1750   0508             				; result into USERAF.
1751   0508 2A D8 1F    	LD	HL,(FLAGHP)	; Encode F' register.
1752   050B CD 23 05    	CALL	ENCODE
1753   050E 2A DA 1F    	LD	HL,(FLAGLP)
1754   0511 CD 23 05    	CALL	ENCODE
1755   0514 32 C4 1F    	LD	(UAFP),A
1756   0517 C9          	RET
1757   0518             
1758   0518             DECODE:
1759   0518             ; Decode bit 7-4 of A register.
1760   0518             ; Each bit is extended to 4 bits.
1761   0518             ; 0 becomes 0000, 1 becomes 0001.
1762   0518             ; The output is stored in HL, which
1763   0518             ; is 16 bits in length.  Also, after
1764   0518             ; execution, bit 7-4 of A register are
1765   0518             ; bit 3-0 of A before execution.
1766   0518             ; Register AF,B,HL are destroyed.
1767   0518             
1768   0518 06 04       	LD	B,4		; Loop 4 times.
1769   051A 29          DRL4	ADD	HL,HL		; Clear rightmost 3
1770   051B             				; bits in HL.
1771   051B 29          	ADD	HL,HL
1772   051C 29          	ADD	HL,HL
1773   051D 07          	RLCA
1774   051E ED 6A       	ADC	HL,HL		; The 4th bit of HL
1775   0520             				; is determined by carry
1776   0520             				; flag, which is the MSB
1777   0520             				; of A register.
1778   0520 10 F8       	DJNZ	DRL4
1779   0522 C9          	RET
1780   0523             
1781   0523             ENCODE:
1782   0523             ; Encode HL register.  Each 4 bits of HL
1783   0523             ; are encoded to 1 bit. 0000 becomes 0,
1784   0523             ; 0001 becomes 1.  The result is stored
1785   0523             ; in bit 3-0 of A register.  Also, after
1786   0523             ; execution, bit 7-4 of A are bit 3-0
1787   0523             ; before execution.
1788   0523             ; Registers AF,B,HL are destroyed.
1789   0523             
1790   0523 06 04       	LD	B,4		; Loop 4 times.
1791   0525 29          ERL4	ADD	HL,HL		; Shift HL left 4 bits.
1792   0526             				; bit 12 of HL will be
1793   0526             				; shifted into the carry flag.
1794   0526 29          	ADD	HL,HL
1795   0527 29          	ADD	HL,HL
1796   0528 29          	ADD	HL,HL
1797   0529 17          	RLA			; Rotate carry flag into
1798   052A             				; A register.
1799   052A 10 F9       	DJNZ ERL4
1800   052C C9          	RET
1801   052D             
1802   052D             ;***********************************************************
1803   052D             SUM1:
1804   052D             ; Calculate the sum of data in a memory
1805   052D             ; block. The starting and ending address
1806   052D             ; of this block are stored in STEPBF+2 - STEPBF+4.
1807   052D             ; Registers AF,BC,DE,HL are destroyed.
1808   052D             
1809   052D CD 3A 05    	CALL	GETPTR		; Get parameters from
1810   0530             				; step buffer.
1811   0530 D8          	RET	C		; Return if the parameters
1812   0531             				; are illegal.
1813   0531             SUM:
1814   0531             ; Calculate the sum of a memory block
1815   0531             ; HL contains the starting address of
1816   0531             ; this block, BC contains the length.
1817   0531             ; The result is stored in A.
1818   0531             ; Registers AF,BC,HL are destroyed.
1819   0531             
1820   0531 AF          	XOR	A		; Clear A
1821   0532 86          SUMCAL	ADD	A,(HL)		; Add
1822   0533 ED A1       	CPI
1823   0535 EA 32 05    	JP	PE,SUMCAL
1824   0538 B7          	OR	A		; Clear flags
1825   0539 C9          	RET
1826   053A             
1827   053A             GETPTR:
1828   053A             ; Get inputs from step buffer.
1829   053A             ; Input: (STEPBF+2) and (STEPBF+3) contain
1830   053A             ;        starting address.
1831   053A             ;        (STEPBF+4) and (STEPBF+5) contain
1832   053A             ;        ending address.
1833   053A             ; Output: HL register contains the starting
1834   053A             ;        address.
1835   053A             ;        BC register contains the length.
1836   053A             ;        Carry flag 0 -- BC positive
1837   053A             ;                   1 -- BC negative
1838   053A             ; Destroyed reg.: AF,BC,DE,HL.
1839   053A             
1840   053A 21 B1 1F    	LD	HL,STEPBF+2
1841   053D 5E          GETP	LD	E,(HL)		; Load starting address
1842   053E             				; into DE.
1843   053E 23          	INC	HL
1844   053F 56          	LD	D,(HL)
1845   0540 23          	INC	HL
1846   0541 4E          	LD	C,(HL)
1847   0542 23          	INC	HL		; Load ending address
1848   0543             				; into HL.
1849   0543 66          	LD	H,(HL)
1850   0544 69          	LD	L,C
1851   0545 B7          	OR	A		; Clear carry flag.
1852   0546 ED 52       	SBC	HL,DE		; Find difference.
1853   0548             				; Carry flag is changed here.
1854   0548 4D          	LD	C,L
1855   0549 44          	LD	B,H
1856   054A 03          	INC	BC		; Now BC contains the
1857   054B             				; length.
1858   054B EB          	EX	DE,HL		; Now HL contains the
1859   054C             				; starting address.
1860   054C C9          	RET
1861   054D             
1862   054D             TAPEIN:
1863   054D             ; Load a memory block from tape.
1864   054D             ; Input: HL -- starting address of the block
1865   054D             ;        BC -- length of the block
1866   054D             ; Output: Carry flag,1 -- reading error
1867   054D             ;                    0 -- no error
1868   054D             ; Destroyed reg. -- AF,BC,DE,HL,AF',BC',DE',HL'
1869   054D             
1870   054D AF          	XOR	A		; Clear carry flag.
1871   054E             				; At beginning, the reading is
1872   054E             				; no error.
1873   054E 08          	EX	AF,AF'
1874   054F CD 5A 05    TLOOP	CALL	GETBYTE		; Read 1 byte from tape.
1875   0552 73          	LD	(HL),E		; Store it into memory.
1876   0553 ED A1       	CPI
1877   0555 EA 4F 05    	JP	PE,TLOOP	; Loop until length
1878   0558             				; is zero.
1879   0558 08          	EX	AF,AF'
1880   0559 C9          	RET
1881   055A             
1882   055A             GETBYTE:
1883   055A             ; Read one byte from tape.
1884   055A             ; Output: E -- data read
1885   055A             ;         Carry of F',1 -- reading error
1886   055A             ;                     0 -- no error
1887   055A             ; Destroy reg. -- AF,DE,AF',BC',DE',HL'
1888   055A             ; Byte format:
1889   055A             
1890   055A             ; start bit bit bit bit bit bit bit bit stop
1891   055A             ;  bit   0   1   2   3   4   5   6   7   bit
1892   055A             
1893   055A CD 6B 05    	CALL	GETBIT		; Get start bit.
1894   055D 16 08       	LD	D,8		; Loop 8 times.
1895   055F CD 6B 05    BLOOP	CALL	GETBIT		; Get 1 data bit.
1896   0562             				; Result in carry flag.
1897   0562 CB 1B       	RR	E		; Rotate it into E.
1898   0564 15          	DEC	D
1899   0565 20 F8       	JR	NZ,BLOOP
1900   0567 CD 6B 05    	CALL	GETBIT		; Get stop bit.
1901   056A C9          	RET
1902   056B             
1903   056B             
1904   056B             GETBIT:
1905   056B             ; Read 1 bit from tape.
1906   056B             ; Output: Carry of F,0 -- this bit is 0
1907   056B             ;                    1 -- this bit is 1
1908   056B             ;        Carry of F',1 -- reading error
1909   056B             ;                    0 -- no error
1910   056B             ; Destroyed reg. -- AF,AF',BC',DE',HL'
1911   056B             ; Bit format:
1912   056B             
1913   056B             ;   0 -- 2K Hz 8 cycles + 1 K Hz 2 cycles.
1914   056B             ;   1 -- 2K Hz 4 cycles + 1 K Hz 4 cycles.
1915   056B             
1916   056B D9          	EXX			; Save HL,BC,DE registers
1917   056C             
1918   056C             ; The tape-bit format of both 0 and 1 are
1919   056C             ; of the same form:  high freq part and low freq part.
1920   056C             ; The difference between 0 and 1 is the
1921   056C             ; number of high freq cycles and low freq
1922   056C             ; cycles.  Thus a high freq period may have
1923   056C             ; two meanings:
1924   056C             ;  i) It is used to count the number of high
1925   056C             ;     freq cycles of the current tape-bit;
1926   056C             ; ii) If a high freq period is detected
1927   056C             ;     immediately after a low freq period, then
1928   056C             ;     this period is the first cycle of the next
1929   056C             ;     tape-bit and is used as a terminator of the
1930   056C             ;     last tape-bit.
1931   056C             
1932   056C             ; Bit 0 of H register is used to indicate the usage
1933   056C             ; of a high freq period.  If this bit is zero, high
1934   056C             ; freq period causes counter increment for the current
1935   056C             ; tape-bit.  If the high freq part has passed, bit 0
1936   056C             ; of H is set and the next high freq period will be used
1937   056C             ; as a terminator.
1938   056C             ; L register is used to up/down count the number of periods.
1939   056C             ; When a high freq period is read, L is increased by
1940   056C             ; 1; when a low freq period is read, L is decreased
1941   056C             ; by 2. (The time duration for each count is 0.5mS.)
1942   056C             ; At the end of a tape-bit, positive and negative L
1943   056C             ; stand for 0 and 1 respectively.
1944   056C             
1945   056C 21 00 00    	LD	HL,0		; Clear bit 0 of H,
1946   056F             				; Set L to 0.
1947   056F CD 8C 05    COUNT	CALL	PERIOD		; Read one period.
1948   0572 14          	INC	D		; The next 2 instructions
1949   0573             				; check if D is zero.  Carry
1950   0573             				; flag is not affected.
1951   0573 15          	DEC	D
1952   0574 20 11       	JR	NZ,TERR		; If D is not zero, jump
1953   0576             				; to error routine TERR.
1954   0576             				; (because the period is too
1955   0576             				; much longer that that of 1K Hz.)
1956   0576 38 06       	JR	C,SHORTP	; If the period is short
1957   0578             				; (2K Hz), jump to SHORTP.
1958   0578 2D          	DEC	L		; The period is 1K Hz,
1959   0579             				; decrease L by 2.  And set
1960   0579             				; bit 0 of H to indicate this
1961   0579             				; tape-bit has passed high freq
1962   0579             				; part and reaches it low freq part.
1963   0579 2D          	DEC	L
1964   057A CB C4       	SET	0,H
1965   057C 18 F1       	JR	COUNT
1966   057E 2C          SHORTP	INC	L		; The period is 2K Hz,
1967   057F             				; increase L by 1.
1968   057F CB 44       	BIT	0,H		; If the tape bit has passed
1969   0581             				; its high freq part, high frequency
1970   0581             				; means this bit is all over and
1971   0581             				; next bit has started.
1972   0581 28 EC       	JR	Z,COUNT
1973   0583             		; L = (# of 2K period) - 2*(# of 1K period)
1974   0583 CB 15       	RL	L
1975   0585             				; 0 --- NCarry (L positive)
1976   0585             				; 1 ---  Carry (L negative)
1977   0585             				; The positive or negative sign of
1978   0585             				; L corresponds to the tape-bit data.
1979   0585             				; 'RL  L' will shift the sign bit of
1980   0585             				; L into carry flag.  After this
1981   0585             				; instruction, the carry flag
1982   0585             				; contains the tape-bit.
1983   0585 D9          	EXX			; Restore BC',DE',HL'
1984   0586 C9          	RET
1985   0587 08          TERR	EX	AF,AF'
1986   0588 37          	SCF			; Set carry flag of F' to indicate error.
1987   0589 08          	EX	AF,AF'
1988   058A D9          	EXX
1989   058B C9          	RET
1990   058C             
1991   058C             PERIOD:
1992   058C             ; Wait the tape to pass one period.
1993   058C             ; The time duration is stored in DE.  The
1994   058C             ; unit is loop count.  Typical value for
1995   058C             ; 2K Hz is 28, for 1K Hz is 56.
1996   058C             ; Use (56+28)/2 as threshold.  The returned
1997   058C             ; result is in carry flag. (1K -- NC, 2K -- C)
1998   058C             ; Register AF and DE are destroyed.
1999   058C             
2000   058C 11 00 00    	LD	DE,0
2001   058F DB 00       LOOPH	IN	A,(KIN)		; bit 7 of port A is Tapein.
2002   0591 13          	INC	DE
2003   0592 17          	RLA
2004   0593 38 FA       	JR	C,LOOPH		; Loop until input goes low.
2005   0595 3E FF       	LD	A,11111111B	; Echo the tape input to
2006   0597             				; speaker on MPF-1.
2007   0597 D3 02       	OUT	(DIGIT),A
2008   0599 DB 00       LOOPL	IN	A,(KIN)
2009   059B 13          	INC	DE
2010   059C 17          	RLA
2011   059D 30 FA       	JR	NC,LOOPL	; Loop until input goes high.
2012   059F 3E 7F       	LD	A,01111111B	; Echo the tape input to
2013   05A1             				; speaker on MPF-1.
2014   05A1 D3 02       	OUT	(DIGIT),A
2015   05A3 7B          	LD	A,E		; Compare the result with
2016   05A4             				; the threshold.
2017   05A4 FE 2A       	CP	MPERIOD
2018   05A6 C9          	RET
2019   05A7             
2020   05A7             ;***********************************************************
2021   05A7             TAPEOUT:
2022   05A7             ; Output a memory block to tape.
2023   05A7             ; Input: HL -- starting address of the block
2024   05A7             ;        BC -- length of the block
2025   05A7             ; Destroyed reg. -- AF,BC,DE,HL,BC',DE',HL'
2026   05A7             
2027   05A7 5E          	LD	E,(HL)		; Get the data.
2028   05A8 CD B1 05    	CALL	OUTBYTE		; Output to tape
2029   05AB ED A1       	CPI
2030   05AD EA A7 05    	JP	PE,TAPEOUT	; Loop until finished.
2031   05B0 C9          	RET
2032   05B1             
2033   05B1             OUTBYTE:
2034   05B1             ; Outout one byte to tape.  For tape-byte
2035   05B1             ; format, see comments on GETBYTE.
2036   05B1             ; Input: E -- data
2037   05B1             ; Destroyed reg. -- AF,DE,BC",DE',HL'
2038   05B1             
2039   05B1 16 08       	LD	D,8		; Loop 8 times.
2040   05B3 B7          	OR	A		; Clear carry flag.
2041   05B4 CD C4 05    	CALL	OUTBIT		; Output start bit.
2042   05B7 CB 1B       OLOOP	RR	E		; Rotate data into carry
2043   05B9 CD C4 05    	CALL	OUTBIT		; Output the carry
2044   05BC 15          	DEC	D
2045   05BD 20 F8       	JR	NZ,OLOOP
2046   05BF 37          	SCF			; Set carry flag.
2047   05C0 CD C4 05    	CALL	OUTBIT		; Output stop bit
2048   05C3 C9          	RET
2049   05C4             
2050   05C4             OUTBIT:
2051   05C4             ; Output one bit to tape.
2052   05C4             ; Input: data in carry flag.
2053   05C4             ; Destroyed reg. -- AF,BC',DE',HL'
2054   05C4 D9          	EXX			; Save BC,DE,HL.
2055   05C5 26 00       	LD	H,0
2056   05C7 38 09       	JR	C,OUT1		; If data=1, output 1.
2057   05C9             OUT0:	;2K 8 cycles, 1K 2 cycles.
2058   05C9 2E 08       	LD	L,ZERO_2K
2059   05CB CD E2 05    	CALL	TONE2K
2060   05CE 2E 02       	LD	L,ZERO_1K
2061   05D0 18 07       	JR	BITEND
2062   05D2             
2063   05D2             OUT1:	;2K 4 cycles, 1K 4 cycles.
2064   05D2 2E 04       	LD	L,ONE_2K
2065   05D4 CD E2 05    	CALL	TONE2K
2066   05D7 2E 04       	LD	L,ONE_1K
2067   05D9 CD DE 05    BITEND	CALL	TONE1K
2068   05DC D9          	EXX			; Restore registers
2069   05DD C9          	RET
2070   05DE             
2071   05DE             ;***********************************************************
2072   05DE             ;
2073   05DE             ;        UTILITY SUBROUTINE
2074   05DE             ;
2075   05DE             ;***********************************************************
2076   05DE             ;
2077   05DE             ; Function: Generate square wave to the MIC & speaker
2078   05DE             ;           on MPF--1
2079   05DE             ; Input :  C -- period = 2*(44+13*C) clock states.
2080   05DE             ;         HL -- number of periods.
2081   05DE             ; Output: none.
2082   05DE             ; Destroyed reg.: AF, B(C), DE, HL.
2083   05DE             ; Call: none.
2084   05DE             
2085   05DE             TONE1K:
2086   05DE 0E 41       	LD	C,F1KHZ
2087   05E0 18 02       	JR	TONE
2088   05E2             TONE2K:	
2089   05E2 0E 1F       	LD	C,F2KHZ
2090   05E4             TONE:				; Half period: 44+13*C states
2091   05E4 29          	ADD	HL,HL		; Double for half-cycle count
2092   05E5 11 01 00    	LD	DE,1
2093   05E8 3E FF       	LD	A,0FFH
2094   05EA D3 02       SQWAVE	OUT	(DIGIT),A	; Bit-7 tapeout
2095   05EC 41          	LD	B,C
2096   05ED 10 FE       	DJNZ	$		; Half period delay
2097   05EF EE 80       	XOR	80H		; Toggle output
2098   05F1 ED 52       	SBC	HL,DE		; Decrement one count
2099   05F3 20 F5       	JR	NZ,SQWAVE
2100   05F5 C9          	RET
2101   05F6             
2102   05F6             ;***********************************************************
2103   05F6             ; Function: check if a memory address is in RAM.
2104   05F6             ; Input: HL -- address to be checked.
2105   05F6             ; Output: Zero flag -- 0, ROM or non-existant;
2106   05F6             ;                      1, RAM.
2107   05F6             ; Destroyed reg.: AF
2108   05F6             ; Call: none
2109   05F6             
2110   05F6             RAMCHK:
2111   05F6 7E          	LD	A,(HL)
2112   05F7 2F          	CPL
2113   05F8 77          	LD	(HL),A
2114   05F9 7E          	LD	A,(HL)
2115   05FA 2F          	CPL
2116   05FB 77          	LD	(HL),A
2117   05FC BE          	CP	(HL)
2118   05FD C9          	RET
2119   05FE             
2120   05FE             ;***********************************************************
2121   05FE             ; Function: Scan the keyboard and display.  Loop until
2122   05FE             ;           a key is detected.  If the same key is already
2123   05FE             ;           pressed when this routine starts execution,
2124   05FE             ;           return when the next key is entered.
2125   05FE             ; Input: IX points to the buffer containing display patterns.
2126   05FE             ;           6 LEDs require 6 bytes of data. (IX) contains the
2127   05FE             ;           pattern for rightmost LED, (IX+5) contains the
2128   05FE             ;           pattern for leftmost LED.
2129   05FE             ; Output: internal code of the key pressed.
2130   05FE             ; Destroyed reg. : AF, B, HL, AF', BC', DE'.
2131   05FE             ;                  All other registers except IY are also
2132   05FE             ;                  changed during execution, but they are
2133   05FE             ;                  retored before return.
2134   05FE             ; Call: SCAN1
2135   05FE             
2136   05FE             SCAN:
2137   05FE DD E5       	PUSH	IX		; Save IX.
2138   0600 21 E6 1F    	LD	HL,TEST
2139   0603 CB 7E       	BIT	7,(HL)		; this bit is set if the user
2140   0605             				; has entered illegal key.  The
2141   0605             				; display will be disabled as
2142   0605             				; a warning to the user.  This
2143   0605             				; is done by replacing the display
2144   0605             				; buffer pointer IX by BLANK.
2145   0605 28 04       	JR	Z,SCPRE
2146   0607 DD 21 A5 07 	LD	IX,BLANK
2147   060B             
2148   060B             ; Wait until all keys are released for 40 ms.
2149   060B             ; (The execution time of SCAN1 is 10 ms,
2150   060B             ; 40 = 10 * 4.)
2151   060B             
2152   060B 06 04       SCPRE	LD	B,4
2153   060D CD 24 06    SCNX	CALL	SCAN1
2154   0610 30 F9       	JR	NC,SCPRE	; If any key is pressed, re-load
2155   0612             				; the debounce counter B by 4.
2156   0612 10 F9       	DJNZ	SCNX
2157   0614 CB BE       	RES	7,(HL)		; Clear error-flag.
2158   0616 DD E1       	POP	IX		; Restore original IX
2159   0618             
2160   0618             ; Loop until any key is pressed.
2161   0618             
2162   0618 CD 24 06    SCLOOP	CALL	SCAN1
2163   061B 38 FB       	JR	C,SCLOOP
2164   061D             
2165   061D             ; Convert the key-position-code returned by SCAN1 to
2166   061D             ; key-internal-code.  This is done by table-lookup.
2167   061D             ; The table used is KEYTAB.
2168   061D             
2169   061D 21 7B 07    KEYMAP	LD	HL,KEYTAB
2170   0620 85          	ADD	A,L
2171   0621 6F          	LD	L,A
2172   0622 7E          	LD	A,(HL)
2173   0623 C9          	RET
2174   0624             
2175   0624             ;***********************************************************
2176   0624             ; Function: Scan keyboard and display one cycle.
2177   0624             ;           Total execution time is about 10 ms (exactly
2178   0624             ;           9.95 ms, 17812 clock states @ 1.79 MHz).
2179   0624             ; Input: Same as SCAN.
2180   0624             ; Output:  i) no key during one scan
2181   0624             ;                  Carry flag -- 1
2182   0624             ;         ii) key pressed during one scan
2183   0624             ;                  Carry flag -- 0,
2184   0624             ;                  A -- position code of the key pressed.
2185   0624             ;                       If more than one key is pressed, A
2186   0624             ;                       contains the largest position-code.
2187   0624             ;                       (This key is the last key scanned.)
2188   0624             ; Destroyed reg: AF, AF', BC', DE'. (see comments on SCAN)
2189   0624             ; Call: none.
2190   0624             
2191   0624             SCAN1:
2192   0624             ; In hardware, the display and keyboard are
2193   0624             ; arranged as a 6 by 6 matrix.  Each column
2194   0624             ; corresponds to one LED and six key buttons.
2195   0624             ; In normal operation, at most one column is
2196   0624             ; active.  The pattern of the active LED is the
2197   0624             ; data output on port C of 8255 I.  The data input
2198   0624             ; from bit 0-5 of port A are the status of key
2199   0624             ; buttons in the active column.  All signals on
2200   0624             ; I/O port are acive low.
2201   0624             
2202   0624 37          	SCF			; Set carry flag
2203   0625 08          	EX	AF,AF'
2204   0626 D9          	EXX
2205   0627             
2206   0627             ; Carry flag F' is used to return the status of
2207   0627             ; the keyboard.  If any key is pressed during one
2208   0627             ; scan, the flag is reset; otherwise, it is set.
2209   0627             ; Initially this flag is set.  A' register is used
2210   0627             ; to store the position-code of the key pressed.
2211   0627             ; In this routine, 36 key positions are checked one
2212   0627             ; by one.  C register contains the cod eof the key
2213   0627             ; being checked.  The value of C is zero at the beginning,
2214   0627             ; and is increased by 1 after each check.  So the code
2215   0627             ; ranges from 0 to 23H (total 36 positions).  On each
2216   0627             ; check, if the input bit is 0 (key pressed), C register
2217   0627             ; is copied into A'.  The carry flag of F' is set also.
2218   0627             ; When some key is detected, the key positions after
2219   0627             ; this key will still be checked.  So if more than
2220   0627             ; one key are pressed during one scan, the code of the
2221   0627             ; last one will be returned.
2222   0627             
2223   0627 0E 00       	LD	C,0		; Initial position code
2224   0629 1E C1       	LD	E,11000001B	; Scan the rightmost digit.
2225   062B 26 06       	LD	H,6
2226   062D             				; to the active column
2227   062D 7B          KCOL	LD	A,E
2228   062E D3 02       	OUT	(DIGIT),A	; Activate one column.
2229   0630 DD 7E 00    	LD	A,(IX)
2230   0633 D3 01       	OUT	(SEG7),A
2231   0635 06 C9       	LD	B,COLDEL
2232   0637 10 FE       	DJNZ	$		; Delay 1.5 ms per digit.
2233   0639 AF          	XOR	A		; Deactivate all display segments
2234   063A D3 01       	OUT	(SEG7),A
2235   063C 7B          	LD	A,E
2236   063D 2F          	CPL
2237   063E F6 C0       	OR	11000000B
2238   0640 D3 02       	OUT	(DIGIT),A
2239   0642 06 06       	LD	B,6		; Each column has 6 keys.
2240   0644 DB 00       	IN	A,(KIN)		; Now bit 0-5 of A contain
2241   0646             				; the status of the 6 keys
2242   0646             				; in the active column.
2243   0646 57          	LD	D,A		; Store A into D
2244   0647 CB 1A       KROW	RR	D		; Rotate D 1 bit right, bit 0
2245   0649             				; of D will be rotated into
2246   0649             				; carry flag.
2247   0649 38 02       	JR	C,NOKEY		; Skip next 2 instructions
2248   064B             				; if the key is not pressed.
2249   064B             				; The next 2 instructions
2250   064B             				; stroe the current position-code
2251   064B             				; into A' and reset carry flag
2252   064B             				; of F' register.
2253   064B 79          	LD	A,C		; Key-in, get key position
2254   064C 08          	EX	AF,AF'		; Save A & Carry in AF'.
2255   064D 0C          NOKEY	INC	C		; Increase current key-code by 1.
2256   064E 10 F7       	DJNZ	KROW		; Loop until 6 keys in the
2257   0650             				; active columns are all checked.
2258   0650 DD 23       	INC	IX
2259   0652 7B          	LD	A,E
2260   0653 E6 3F       	AND	00111111B
2261   0655 CB 07       	RLC	A
2262   0657 F6 C0       	OR	11000000B
2263   0659 5F          	LD	E,A
2264   065A 25          	DEC	H
2265   065B 20 D0       	JR	NZ,KCOL
2266   065D 11 FA FF    	LD	DE,-6
2267   0660 DD 19       	ADD	IX,DE		; Get original IX
2268   0662 D9          	EXX
2269   0663 08          	EX	AF,AF'
2270   0664 C9          	RET
2271   0665             
2272   0665             ;***********************************************************
2273   0665             ; Function: Convert the 2 byte data stored in DE to
2274   0665             ;           7-segment display format.  The output is stored
2275   0665             ;           in the address filed of DISPBF (display buffer),
2276   0665             ;           most significant digit in DISPBF+5.
2277   0665             ;           This routine is usually used by the monitor only.
2278   0665             ; Destroyed reg: AF, HL.
2279   0665             ; Call: HEX7SG
2280   0665             
2281   0665             ADDRDP:
2282   0665 21 B8 1F    	LD	HL,DISPBF+2
2283   0668 7B          	LD	A,E
2284   0669 CD 78 06    	CALL	HEX7SG
2285   066C 7A          	LD	A,D
2286   066D CD 78 06    	CALL	HEX7SG
2287   0670 C9          	RET
2288   0671             
2289   0671             ;***********************************************************
2290   0671             ; Function: Convert the data stored in A to 7-segment
2291   0671             ;           display format.  1 byte is converted to 2
2292   0671             ;           digits.  The result is stored in the data
2293   0671             ;           field of display buffer (DISPBF).
2294   0671             ;           This routine is usually used by the monitor only.
2295   0671             ; Destroyed reg: AF, HL.
2296   0671             ; Call: HEX7SG
2297   0671              
2298   0671             DATADP:
2299   0671 21 B6 1F    	LD	HL,DISPBF
2300   0674 CD 78 06    	CALL	HEX7SG
2301   0677 C9          	RET
2302   0678             
2303   0678             ;***********************************************************
2304   0678             ; Function: Convert binary data to 7-segment display
2305   0678             ;           format.
2306   0678             ; Input: 1 byte in A register.
2307   0678             ;        HL points to the result buffer.
2308   0678             ; Output: Pattern for 2 digits.  Low order digit in (HL),
2309   0678             ;         high order digit in (HL+1).
2310   0678             ;         HL becomes HL+2.
2311   0678             ; Destroy reg: AF, HL.
2312   0678             ; Call: HEX7
2313   0678             
2314   0678             HEX7SG:
2315   0678 F5          	PUSH	AF
2316   0679 CD 89 06    	CALL	HEX7
2317   067C 77          	LD	(HL),A
2318   067D 23          	INC	HL
2319   067E F1          	POP	AF
2320   067F 0F          	RRCA
2321   0680 0F          	RRCA
2322   0681 0F          	RRCA
2323   0682 0F          	RRCA
2324   0683 CD 89 06    	CALL	HEX7
2325   0686 77          	LD	(HL),A
2326   0687 23          	INC	HL
2327   0688 C9          	RET
2328   0689             
2329   0689             ;***********************************************************
2330   0689             ; Function: Convert binary data to 7-segment display
2331   0689             ;           format.
2332   0689             ; Input: A -- LSB 4 bits contains the binary data.
2333   0689             ; Output: A -- display pattern for 1 digit.
2334   0689             ; Destroyed reg: AF
2335   0689             ; Call: none
2336   0689             
2337   0689             HEX7:
2338   0689 E5          	PUSH	HL
2339   068A 21 F0 07    	LD	HL,SEGTAB
2340   068D E6 0F       	AND	0FH
2341   068F 85          	ADD	A,L
2342   0690 6F          	LD	L,A
2343   0691 7E          	LD	A,(HL)
2344   0692 E1          	POP	HL
2345   0693 C9          	RET
2346   0694             
2347   0694             
2348   0694             ;***********************************************************
2349   0694             ; Function: RAM 1800-1FFF self-check.
2350   0694             ; Input: none
2351   0694             ; Output: none
2352   0694             ; Destroyed reg: AF, BC, HL
2353   0694             ; Call: RAMCHK
2354   0694             
2355   0694             RAMTEST:
2356   0694 21 00 18    	LD	HL,1800H
2357   0697 01 00 08    	LD	BC,800H
2358   069A CD F6 05    RAMT	CALL	RAMCHK
2359   069D 28 01       	JR	Z,TNEXT
2360   069F 76          	HALT			; If error.
2361   06A0 ED A1       TNEXT	CPI
2362   06A2 EA 9A 06    	JP	PE,RAMT
2363   06A5 C7          	RST	00H		; Display 'uPF--1'.
2364   06A6             
2365   06A6             ;***********************************************************
2366   06A6             ; Function: Monitor ROM self-check. Add the data of address
2367   06A6             ;           0000-0800.  If the sum equals to 0. Reset the monitor
2368   06A6             ;           and display 'uPF--1'. If the sum is not 0, which
2369   06A6             ;           indicates error, HALT.
2370   06A6             ; Input: none
2371   06A6             ; Output: none
2372   06A6             ; Destroyed reg: AF, BC, HL
2373   06A6             ; Call: SUM.
2374   06A6             
2375   06A6             ROMTEST:
2376   06A6 21 00 00    	LD	HL,0
2377   06A9 01 00 08    	LD	BC,800H
2378   06AC CD 31 05    	CALL	SUM
2379   06AF 28 01       	JR	Z,SUMOK
2380   06B1 76          	HALT			; If error.
2381   06B2 C7          SUMOK	RST	00H		; Display 'uPF--1'.
2382   06B3 32 E5 1F    INI3	LD	(POWERUP),A	; Load power-code into
2383   06B6             				; (POWERUP). The monitor
2384   06B6             				; uses the location to decide
2385   06B6             				; whether a reset signal is
2386   06B6             				; on power-up
2387   06B6 3E 55       	LD	A,55H
2388   06B8 32 F0 1F    	LD	(BEEPSET),A
2389   06BB 3E 44       	LD	A,44H
2390   06BD 32 F1 1F    	LD	(FBEEP),A	; Beep frequency when key is
2391   06C0             				; pressed.
2392   06C0 21 F2 1F    	LD	HL,TBEEP
2393   06C3 36 2F       	LD	(HL),2FH	; Time duration of beep when
2394   06C5 23          	INC	HL
2395   06C6 36 00       	LD	(HL),0
2396   06C8             				; key is pressed.
2397   06C8 C3 D8 03    	JP	INI4
2398   06CB             
2399   06CB F5          BEEP	PUSH	AF
2400   06CC 21 F1 1F    	LD	HL,FBEEP
2401   06CF 4E          	LD	C,(HL)
2402   06D0 2A F2 1F    	LD	HL,(TBEEP)
2403   06D3 3A F0 1F    	LD	A,(BEEPSET)
2404   06D6 FE 55       	CP	55H
2405   06D8 20 03       	JR	NZ,NOTONE	; There is no beep sound when
2406   06DA             				; the key is pressed if data
2407   06DA             				; of (BEEPSET) is not 55H
2408   06DA CD E4 05    	CALL	TONE
2409   06DD             NOTONE:
2410   06DD F1          	POP AF
2411   06DE C3 E9 00    	JP	KEYEXEC		; After a key is detected, determine
2412   06E1             				; what action should the monitor take.
2413   06E1             				; KEYEXEC uses the next 3 factors
2414   06E1             				; to get the entry point of proper
2415   06E1             				; service routine: key-code, sTATE
2416   06E1             				; and STMINOR (Minor-State).
2417   06E1             ; Below are the branch tables for each key and
2418   06E1             ; state.  The first entry of each table is
2419   06E1             ; a base address, other entries are the offset to
2420   06E1             ; this address.  Offset is only one byte long,
2421   06E1             ; which is much shorter that the 2-byte address.
2422   06E1             ; This can save monitor code space.
2423   06E1             
2424   0737             KSUBFUN .org	0737H
2425   0737 1B 01       	.dw	KINC
2426   0739 00          	.db	-KINC+KINC
2427   073A 05          	.db	-KINC+KDEC
2428   073B 0A          	.db	-KINC+KGO
2429   073C 0F          	.db	-KINC+KSTEP
2430   073D 1A          	.db	-KINC+KDATA
2431   073E 2C          	.db	-KINC+KSBR
2432   073F 42          	.db	-KINC+KINS
2433   0740 7B          	.db	-KINC+KDEL
2434   0741 C2 01       KFUN	.dw	KPC
2435   0743 00          	.db	-KPC+KPC
2436   0744 1C          	.db	-KPC+KADDR
2437   0745 0A          	.db	-KPC+KCBR
2438   0746 14          	.db	-KPC+KREG
2439   0747 20          	.db	-KPC+KMV
2440   0748 20          	.db	-KPC+KRL
2441   0749 26          	.db	-KPC+KWT
2442   074A 26          	.db	-KPC+KRT
2443   074B EC 01       HTAB	.dw	HFIX
2444   074D 00          	.db	-HFIX+HFIX
2445   074E 16          	.db	-HFIX+HAD
2446   074F 03          	.db	-HFIX+HDA
2447   0750 26          	.db	-HFIX+HRGFIX
2448   0751 34          	.db	-HFIX+HMV
2449   0752 34          	.db	-HFIX+HRL
2450   0753 34          	.db	-HFIX+HWT
2451   0754 34          	.db	-HFIX+HRT
2452   0755 26          	.db	-HFIX+HRGAD
2453   0756 44          	.db	-HFIX+HRGDA
2454   0757 3D 02       ITAB	.dw	IFIX
2455   0759 00          	.db	-IFIX+IFIX
2456   075A 03          	.db	-IFIX+IAD
2457   075B 03          	.db	-IFIX+IDA
2458   075C 00          	.db	-IFIX+IRGFIX
2459   075D 0E          	.db	-IFIX+IMV
2460   075E 0E          	.db	-IFIX+IRL
2461   075F 0E          	.db	-IFIX+IWT
2462   0760 0E          	.db	-IFIX+IRT
2463   0761 1F          	.db	-IFIX+IRGAD
2464   0762 1F          	.db	-IFIX+IRGDA
2465   0763 6B 02       DTAB	.dw	DFIX
2466   0765 00          	.db	-DFIX+DFIX
2467   0766 03          	.db	-DFIX+DAD
2468   0767 03          	.db	-DFIX+DDA
2469   0768 00          	.db	-DFIX+DRGFIX
2470   0769 0E          	.db	-DFIX+DMV
2471   076A 0E          	.db	-DFIX+DRL
2472   076B 0E          	.db	-DFIX+DWT
2473   076C 0E          	.db	-DFIX+DRT
2474   076D 1F          	.db	-DFIX+DRGAD
2475   076E 1F          	.db	-DFIX+DRGDA
2476   076F 99 02       GTAB	.dw	GFIX
2477   0771 00          	.db	-GFIX+GFIX
2478   0772 03          	.db	-GFIX+GAD
2479   0773 03          	.db	-GFIX+GDA
2480   0774 00          	.db	-GFIX+GRGFIX
2481   0775 4B          	.db	-GFIX+GMV
2482   0776 6D          	.db	-GFIX+GRL
2483   0777 8B          	.db	-GFIX+GWT
2484   0778 C1          	.db	-GFIX+GRT
2485   0779 00          	.db	-GFIX+GRGAD
2486   077A 00          	.db	-GFIX+GRGDA
2487   077B             
2488   077B             ; Key-position-code to key-internal-code conversion table.
2489   077B             
2490   077B             KEYTAB:
2491   077B 03          K0	.db	03H	; HEX_3
2492   077C 07          K1	.db	07H	; HEX_7
2493   077D 0B          K2	.db	0BH	; HEX_B
2494   077E 0F          K3	.db	0FH	; HEX_F
2495   077F 20          K4	.db	20H	; NOT USED
2496   0780 21          K5	.db	21H	; NOT USED
2497   0781 02          K6	.db	02H	; HEX_2
2498   0782 06          K7	.db	06H	; HEX_6
2499   0783 0A          K8	.db	0AH	; HEX_A
2500   0784 0E          K9	.db	0EH	; HEX_E
2501   0785 22          K0A	.db	22H	; NOT USED
2502   0786 23          K0B	.db	23H	; NOT USED
2503   0787 01          K0C	.db	01H	; HEX_1
2504   0788 05          K0D	.db	05H	; HEX_5
2505   0789 09          K0E	.db	09H	; HEX_9
2506   078A 0D          K0F	.db	0DH	; HEX_D
2507   078B 13          K10	.db	13H	; STEP
2508   078C 1F          K11	.db	1FH	; TAPERD
2509   078D 00          K12	.db	00H	; HEX_0
2510   078E 04          K13	.db	04H	; HEX_4
2511   078F 08          K14	.db	08H	; HEX_8
2512   0790 0C          K15	.db	0CH	; HEX_C
2513   0791 12          K16	.db	12H	; GO
2514   0792 1E          K17	.db	1EH	; TAPEWR
2515   0793 1A          K18	.db	1AH	; CBR
2516   0794 18          K19	.db	18H	; PC
2517   0795 1B          K1A	.db	1BH	; REG
2518   0796 19          K1B	.db	19H	; ADDR
2519   0797 17          K1C	.db	17H	; DEL
2520   0798 1D          K1D	.db	1DH	; RELA
2521   0799 15          K1E	.db	15H	; SBR
2522   079A 11          K1F	.db	11H	; -
2523   079B 14          K20	.db	14H	; DATA
2524   079C 10          K21	.db	10H	; +
2525   079D 16          K22	.db	16H	; INS
2526   079E 1C          K23	.db	1CH	; MOVE
2527   079F             ;
2528   079F             ;
2529   079F             ;
2530   079F             ;
2531   079F 30          MPF_I	.db	30H	; '1'
2532   07A0 02          	.db	02H	; '-'
2533   07A1 02          	.db	02H	; '-'
2534   07A2 0F          	.db	0FH	; 'F'
2535   07A3 1F          	.db	1FH	; 'P'
2536   07A4 A1          	.db	0A1H	; 'u'
2537   07A5 00          BLANK	.db	0
2538   07A6 00          	.db	0
2539   07A7 00          	.db	0
2540   07A8 00          	.db	0
2541   07A9 00          ERR_	.db	0
2542   07AA 00          	.db	0
2543   07AB 03          	.db	03H	; 'R"
2544   07AC 03          	.db	03H	; 'R"
2545   07AD 8F          	.db	8FH	; 'E"
2546   07AE 02          	.db	02H	; '-"
2547   07AF 1F          SYS_SP	.db	1FH	; 'P"
2548   07B0 AE          	.db	0AEH	; 'S"
2549   07B1 02          	.db	02H	; '-"
2550   07B2 AE          	.db	0AEH	; 'S"
2551   07B3 B6          	.db	0B6H	; 'Y"
2552   07B4 AE          	.db	0AEH	; 'S"
2553   07B5 1F          ERR_SP	.db	1FH	; 'P"
2554   07B6 AE          	.db	0AEH	; 'S"
2555   07B7 02          	.db	02H	; '-"
2556   07B8 03          	.db	03H	; 'R"
2557   07B9 03          	.db	03H	; 'R"
2558   07BA 8F          	.db	8FH	; 'E"
2559   07BB 00          	.db	00H
2560   07BC AE          STEPTAB	.db	0AEH	; 'S"
2561   07BD 8F          	.db	8FH	; 'E"
2562   07BE B3          	.db	0B3H	; 'D"
2563   07BF 00          	.db	00H
2564   07C0 AE          	.db	0AEH	; 'S"
2565   07C1 B3          	.db	0B3H	; 'D"
2566   07C2 00          	.db	00H
2567   07C3 00          	.db	00H
2568   07C4 0F          	.db	0FH	; 'F"
2569   07C5 AE          	.db	0AEH	; 'S"
2570   07C6 8F          	.db	8FH	; 'E"
2571   07C7 00          	.db	00H
2572   07C8 0F          	.db	0FH	; 'F"
2573   07C9 00          	.db	00H
2574   07CA 00          REG_	.db	00H
2575   07CB 00          	.db	00H
2576   07CC 02          	.db	02H	; '-"
2577   07CD BE          	.db	0BEH	; 'G"
2578   07CE 8F          	.db	8FH	; 'E"
2579   07CF 03          	.db	03H	; 'R"
2580   07D0 0F 3F       RGTAB	.dw	3F0FH	; 'AF'
2581   07D2 8D A7       	.dw	0A78DH	; 'BC'
2582   07D4 8F B3       	.dw	0B38FH	; 'DE'
2583   07D6 85 37       	.dw	3785H	; 'HL'
2584   07D8 4F 3F       	.dw	3F4FH	; 'AF.'
2585   07DA CD A7       	.dw	0A7CDH	; 'BC.'
2586   07DC CF B3       	.dw	0B3CFH	; 'DE.'
2587   07DE C5 37       	.dw	37C5H	; 'HL.'
2588   07E0 07 30       	.dw	3007H	; 'IX'
2589   07E2 B6 30       	.dw	30B6H	; 'IY'
2590   07E4 1F AE       	.dw	0AE1FH	; 'SP'
2591   07E6 0F 30       	.dw	300FH	; 'IF'
2592   07E8 37 0F       	.dw	0F37H	; 'FH'
2593   07EA 85 0F       	.dw	0F85H	; 'FL'
2594   07EC 77 0F       	.dw	0F77H	; 'FH.'
2595   07EE C5 0F       	.dw	0FC5H	; 'FL.'
2596   07F0 BD          SEGTAB	.db	0BDH	; '0'
2597   07F1 30          	.db	30H	; '1'
2598   07F2 9B          	.db	9BH	; '2'
2599   07F3 BA          	.db	0BAH	; '3'
2600   07F4 36          	.db	36H	; '4'
2601   07F5 AE          	.db	0AEH	; '5'
2602   07F6 AF          	.db	0AFH	; '6'
2603   07F7 38          	.db	38H	; '7'
2604   07F8 BF          	.db	0BFH	; '8'
2605   07F9 BE          	.db	0BEH	; '9'
2606   07FA 3F          	.db	3FH	; 'A'
2607   07FB A7          	.db	0A7H	; 'B'
2608   07FC 8D          	.db	8DH	; 'C'
2609   07FD B3          	.db	0B3H	; 'D'
2610   07FE 8F          	.db	8FH	; 'E'
2611   07FF 0F          	.db	0FH	; 'F'
2612   0800             
2613   0800             ;***********************************************************
2614   0800             ; SYSTEM RAM AREA
2615   1F9F             USERSTK	.org	1F9FH
2616   1F9F             	.ds	16
2617   1FAF             SYSSTK:	.org	1FAFH
2618   1FAF             STEPBF	.ds	7
2619   1FB6             DISPBF	.ds	6
2620   1FBC             REGBF:
2621   1FBC             USERAF	.ds	2
2622   1FBE             USERBC	.ds	2
2623   1FC0             USERDE	.ds	2
2624   1FC2             USERHL	.ds	2
2625   1FC4             UAFP	.ds	2
2626   1FC6             UBCP	.ds	2
2627   1FC8             UDEP	.ds	2
2628   1FCA             UHLP	.ds	2
2629   1FCC             USERIX	.ds	2
2630   1FCE             USERIY	.ds	2
2631   1FD0             USERSP	.ds	2
2632   1FD2             USERIF	.ds	2
2633   1FD4             FLAGH	.ds	2
2634   1FD6             FLAGL	.ds	2
2635   1FD8             FLAGHP	.ds	2
2636   1FDA             FLAGLP	.ds	2
2637   1FDC             USERPC	.ds	2
2638   1FDE             ;
2639   1FDE             ADSAVE	.ds	2	; Contains the address being
2640   1FE0             			; displayed now.
2641   1FE0             BRAD	.ds	2	; Break point address
2642   1FE2             BRDA	.ds	1	; Data of break point address
2643   1FE3             STMINOR	.ds	1	; Minor state
2644   1FE4             STATE	.ds	1	; State
2645   1FE5             POWERUP	.ds	1	; Power-up initialization
2646   1FE6             TEST	.ds	1	; Flag, bit 0 -- set when function
2647   1FE7             			;       or subfunction key is hit.
2648   1FE7             			;       bit 7 -- set when illegal key
2649   1FE7             			;       is entered.
2650   1FE7             ATEMP	.ds	1	; Temporary storage
2651   1FE8             HLTEMP	.ds	2	; Temporary storage
2652   1FEA             TEMP	.ds	4	; See comments on routine GDA.
2653   1FEE             IM1AD	.ds	2	; Contains the address of Opcode 'FF'
2654   1FF0             			; service routine. (RST 38H, mode 1
2655   1FF0             			; interrupt, etc.)
2656   1FF0             BEEPSET	.ds	1	; Default value is 55H
2657   1FF1             FBEEP	.ds	1	; Beep frequency
2658   1FF2             TBEEP	.ds	2	; Time duration of beep
2659   1FF4             	.endtasm: Number of errors = 0
